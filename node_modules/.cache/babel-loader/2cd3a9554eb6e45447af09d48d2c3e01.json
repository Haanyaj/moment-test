{"ast":null,"code":"/**\n    * @license\n    * Copyright 2020 Google LLC. All Rights Reserved.\n    * Licensed under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License.\n    * You may obtain a copy of the License at\n    *\n    * http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software\n    * distributed under the License is distributed on an \"AS IS\" BASIS,\n    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    * See the License for the specific language governing permissions and\n    * limitations under the License.\n    * =============================================================================\n    */\nimport * as tf from \"@tensorflow/tfjs-core\";\nimport { tidy, Tensor, util, browser, pad3d, image, oneHot, scalar, range, div, getBackend, tensor, backend } from \"@tensorflow/tfjs-core\";\nimport { loadGraphModel } from \"@tensorflow/tfjs-converter\";\n\nvar extendStatics = function (e, t) {\n  return (extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  })(e, t);\n};\n\nfunction __extends(e, t) {\n  function n() {\n    this.constructor = e;\n  }\n\n  extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n}\n\nvar __assign = function () {\n  return (__assign = Object.assign || function (e) {\n    for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n\n    return e;\n  }).apply(this, arguments);\n};\n\nfunction __awaiter(e, t, n, r) {\n  return new (n || (n = Promise))(function (o, i) {\n    function a(e) {\n      try {\n        d(r.next(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function s(e) {\n      try {\n        d(r.throw(e));\n      } catch (e) {\n        i(e);\n      }\n    }\n\n    function d(e) {\n      e.done ? o(e.value) : new n(function (t) {\n        t(e.value);\n      }).then(a, s);\n    }\n\n    d((r = r.apply(e, t || [])).next());\n  });\n}\n\nfunction __generator(e, t) {\n  var n,\n      r,\n      o,\n      i,\n      a = {\n    label: 0,\n    sent: function () {\n      if (1 & o[0]) throw o[1];\n      return o[1];\n    },\n    trys: [],\n    ops: []\n  };\n  return i = {\n    next: s(0),\n    throw: s(1),\n    return: s(2)\n  }, \"function\" == typeof Symbol && (i[Symbol.iterator] = function () {\n    return this;\n  }), i;\n\n  function s(i) {\n    return function (s) {\n      return function (i) {\n        if (n) throw new TypeError(\"Generator is already executing.\");\n\n        for (; a;) try {\n          if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done) return o;\n\n          switch (r = 0, o && (i = [2 & i[0], o.value]), i[0]) {\n            case 0:\n            case 1:\n              o = i;\n              break;\n\n            case 4:\n              return a.label++, {\n                value: i[1],\n                done: !1\n              };\n\n            case 5:\n              a.label++, r = i[1], i = [0];\n              continue;\n\n            case 7:\n              i = a.ops.pop(), a.trys.pop();\n              continue;\n\n            default:\n              if (!(o = (o = a.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {\n                a = 0;\n                continue;\n              }\n\n              if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {\n                a.label = i[1];\n                break;\n              }\n\n              if (6 === i[0] && a.label < o[1]) {\n                a.label = o[1], o = i;\n                break;\n              }\n\n              if (o && a.label < o[2]) {\n                a.label = o[2], a.ops.push(i);\n                break;\n              }\n\n              o[2] && a.ops.pop(), a.trys.pop();\n              continue;\n          }\n\n          i = t.call(e, a);\n        } catch (e) {\n          i = [6, e], r = 0;\n        } finally {\n          n = o = 0;\n        }\n\n        if (5 & i[0]) throw i[1];\n        return {\n          value: i[0] ? i[1] : void 0,\n          done: !0\n        };\n      }([i, s]);\n    };\n  }\n}\n\nfunction toFlattenedOneHotPartMap(e) {\n  var t = e.shape[2],\n      n = e.argMax(2).reshape([-1]);\n  return oneHot(n, t);\n}\n\nfunction clipByMask2d(e, t) {\n  return e.mul(t);\n}\n\nfunction toMaskTensor(e, t) {\n  return tidy(function () {\n    return e.greater(scalar(t)).toInt();\n  });\n}\n\nfunction decodePartSegmentation(e, t) {\n  var n = t.shape,\n      r = n[0],\n      o = n[1],\n      i = n[2];\n  return tidy(function () {\n    var n = toFlattenedOneHotPartMap(t),\n        a = range(0, i, 1, \"int32\").expandDims(1);\n    return clipByMask2d(n.matMul(a).toInt().reshape([r, o]).add(scalar(1, \"int32\")), e).sub(scalar(1, \"int32\"));\n  });\n}\n\nfunction decodeOnlyPartSegmentation(e) {\n  var t = e.shape,\n      n = t[0],\n      r = t[1],\n      o = t[2];\n  return tidy(function () {\n    var t = toFlattenedOneHotPartMap(e),\n        i = range(0, o, 1, \"int32\").expandDims(1);\n    return t.matMul(i).toInt().reshape([n, r]);\n  });\n}\n\nvar BaseModel = function () {\n  function e(e, t) {\n    this.model = e, this.outputStride = t;\n    var n = this.model.inputs[0].shape;\n    util.assert(-1 === n[1] && -1 === n[2], function () {\n      return \"Input shape [\" + n[1] + \", \" + n[2] + \"] must both be equal to or -1\";\n    });\n  }\n\n  return e.prototype.predict = function (e) {\n    var t = this;\n    return tidy(function () {\n      var n = t.preprocessInput(e.toFloat()).expandDims(0),\n          r = t.model.predict(n).map(function (e) {\n        return e.squeeze([0]);\n      }),\n          o = t.nameOutputResults(r);\n      return {\n        heatmapScores: o.heatmap.sigmoid(),\n        offsets: o.offsets,\n        displacementFwd: o.displacementFwd,\n        displacementBwd: o.displacementBwd,\n        segmentation: o.segmentation,\n        partHeatmaps: o.partHeatmaps,\n        longOffsets: o.longOffsets,\n        partOffsets: o.partOffsets\n      };\n    });\n  }, e.prototype.dispose = function () {\n    this.model.dispose();\n  }, e;\n}(),\n    MobileNet = function (e) {\n  function t() {\n    return null !== e && e.apply(this, arguments) || this;\n  }\n\n  return __extends(t, e), t.prototype.preprocessInput = function (e) {\n    return tidy(function () {\n      return div(e, 127.5).sub(1);\n    });\n  }, t.prototype.nameOutputResults = function (e) {\n    return {\n      offsets: e[0],\n      segmentation: e[1],\n      partHeatmaps: e[2],\n      longOffsets: e[3],\n      heatmap: e[4],\n      displacementFwd: e[5],\n      displacementBwd: e[6],\n      partOffsets: e[7]\n    };\n  }, t;\n}(BaseModel),\n    PART_NAMES = [\"nose\", \"leftEye\", \"rightEye\", \"leftEar\", \"rightEar\", \"leftShoulder\", \"rightShoulder\", \"leftElbow\", \"rightElbow\", \"leftWrist\", \"rightWrist\", \"leftHip\", \"rightHip\", \"leftKnee\", \"rightKnee\", \"leftAnkle\", \"rightAnkle\"],\n    NUM_KEYPOINTS = PART_NAMES.length,\n    PART_IDS = PART_NAMES.reduce(function (e, t, n) {\n  return e[t] = n, e;\n}, {}),\n    CONNECTED_PART_NAMES = [[\"leftHip\", \"leftShoulder\"], [\"leftElbow\", \"leftShoulder\"], [\"leftElbow\", \"leftWrist\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"rightHip\", \"rightShoulder\"], [\"rightElbow\", \"rightShoulder\"], [\"rightElbow\", \"rightWrist\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"], [\"leftShoulder\", \"rightShoulder\"], [\"leftHip\", \"rightHip\"]],\n    POSE_CHAIN = [[\"nose\", \"leftEye\"], [\"leftEye\", \"leftEar\"], [\"nose\", \"rightEye\"], [\"rightEye\", \"rightEar\"], [\"nose\", \"leftShoulder\"], [\"leftShoulder\", \"leftElbow\"], [\"leftElbow\", \"leftWrist\"], [\"leftShoulder\", \"leftHip\"], [\"leftHip\", \"leftKnee\"], [\"leftKnee\", \"leftAnkle\"], [\"nose\", \"rightShoulder\"], [\"rightShoulder\", \"rightElbow\"], [\"rightElbow\", \"rightWrist\"], [\"rightShoulder\", \"rightHip\"], [\"rightHip\", \"rightKnee\"], [\"rightKnee\", \"rightAnkle\"]],\n    CONNECTED_PART_INDICES = CONNECTED_PART_NAMES.map(function (e) {\n  var t = e[0],\n      n = e[1];\n  return [PART_IDS[t], PART_IDS[n]];\n});\n\nfunction getScale(e, t, n) {\n  var r = e[0],\n      o = e[1],\n      i = t[0],\n      a = t[1],\n      s = n.top,\n      d = n.bottom;\n  return [a / (n.left + n.right + o), i / (s + d + r)];\n}\n\nfunction getOffsetPoint(e, t, n, r) {\n  return {\n    y: r.get(e, t, n),\n    x: r.get(e, t, n + NUM_KEYPOINTS)\n  };\n}\n\nfunction getImageCoords(e, t, n) {\n  var r = getOffsetPoint(e.heatmapY, e.heatmapX, e.id, n),\n      o = r.y,\n      i = r.x;\n  return {\n    x: e.heatmapX * t + i,\n    y: e.heatmapY * t + o\n  };\n}\n\nfunction clamp(e, t, n) {\n  return e < t ? t : e > n ? n : e;\n}\n\nfunction squaredDistance(e, t, n, r) {\n  var o = n - e,\n      i = r - t;\n  return o * o + i * i;\n}\n\nfunction addVectors(e, t) {\n  return {\n    x: e.x + t.x,\n    y: e.y + t.y\n  };\n}\n\nfunction computeDistance(e, t, n) {\n  void 0 === n && (n = .3);\n\n  for (var r = 0, o = 0, i = 0; i < e.length; i++) t.keypoints[i].score > n && (o += 1, r += Math.pow(e[i].x - t.keypoints[i].position.x, 2) + Math.pow(e[i].y - t.keypoints[i].position.y, 2));\n\n  return 0 === o ? r = 1 / 0 : r /= o, r;\n}\n\nfunction convertToPositionInOuput(e, t, n, r) {\n  var o = t[0],\n      i = t[1],\n      a = n[0],\n      s = n[1],\n      d = Math.round(((o + e.y + 1) * s - 1) / r);\n  return {\n    x: Math.round(((i + e.x + 1) * a - 1) / r),\n    y: d\n  };\n}\n\nfunction getEmbedding(e, t, n, r, o, i, a) {\n  for (var s = a[0], d = a[1], u = n(e), l = u.y * r + u.x, f = o[NUM_KEYPOINTS * (2 * l) + t], c = o[NUM_KEYPOINTS * (2 * l + 1) + t], p = e.y + f, h = e.x + c, m = 0; m < i; m++) {\n    p = Math.min(p, s - 1);\n    var g = n({\n      x: h = Math.min(h, d - 1),\n      y: p\n    }),\n        v = g.y * r + g.x;\n    p += f = o[NUM_KEYPOINTS * (2 * v) + t], h += c = o[NUM_KEYPOINTS * (2 * v + 1) + t];\n  }\n\n  return {\n    x: h,\n    y: p\n  };\n}\n\nfunction matchEmbeddingToInstance(e, t, n, r, o, i, a, s, d, u) {\n  for (var l = o[0], f = o[1], c = i[0], p = i[1], h = s[0], m = s[1], g = [], v = function (e) {\n    return convertToPositionInOuput(e, [l, f], [c, p], d);\n  }, S = 0; S < r; S++) {\n    var _ = getEmbedding(e, S, v, a, t, u, [h, m]);\n\n    g.push(_);\n  }\n\n  for (var I = -1, w = 1 / 0, E = 0; E < n.length; E++) {\n    var N = computeDistance(g, n[E]);\n    N < w && (I = E, w = N);\n  }\n\n  return I;\n}\n\nfunction getOutputResolution(e, t) {\n  var n = e[0],\n      r = e[1];\n  return [Math.round((r - 1) / t + 1), Math.round((n - 1) / t + 1)];\n}\n\nfunction decodeMultipleMasksCPU(e, t, n, r, o, i, a, s, d, u) {\n  var l = a[0],\n      f = a[1];\n  void 0 === u && (u = 5);\n\n  for (var c = n.map(function (e) {\n    return new Uint8Array(r * o).fill(0);\n  }), p = s.top, h = s.left, m = getScale([r, o], [l, f], s), g = m[0], v = m[1], S = getOutputResolution([l, f], i)[0], _ = 0; _ < r; _ += 1) for (var I = 0; I < o; I += 1) {\n    var w = _ * o + I;\n\n    if (1 === e[w]) {\n      var E = matchEmbeddingToInstance({\n        x: I,\n        y: _\n      }, t, n, u, [p, h], [g, v], S, [r, o], i, d);\n      E >= 0 && (c[E][w] = 1);\n    }\n  }\n\n  return c;\n}\n\nfunction decodeMultiplePartMasksCPU(e, t, n, r, o, i, a, s, d, u, l) {\n  var f = s[0],\n      c = s[1];\n  void 0 === l && (l = 5);\n\n  for (var p = r.map(function (e) {\n    return new Int32Array(o * i).fill(-1);\n  }), h = d.top, m = d.left, g = getScale([o, i], [f, c], d), v = g[0], S = g[1], _ = getOutputResolution([f, c], a)[0], I = 0; I < o; I += 1) for (var w = 0; w < i; w += 1) {\n    var E = I * i + w;\n\n    if (1 === e[E]) {\n      var N = matchEmbeddingToInstance({\n        x: w,\n        y: I\n      }, t, r, l, [h, m], [v, S], _, [o, i], a, u);\n      N >= 0 && (p[N][E] = n[E]);\n    }\n  }\n\n  return p;\n}\n\nfunction decodeMultipleMasksWebGl(e, t, n, r, o, i, a, s, d, u, l) {\n  for (var f = a[0], c = a[1], p = e.shape, h = p[0], m = p[1], g = t.shape.slice(0, 2), v = g[0], S = g[1], _ = t.reshape([v, S, 2, NUM_KEYPOINTS]), I = new Float32Array(l * NUM_KEYPOINTS * 3).fill(0), w = 0; w < n.length; w++) for (var E = w * NUM_KEYPOINTS * 3, N = n[w], T = 0; T < NUM_KEYPOINTS; T++) {\n    var A = N.keypoints[T],\n        P = E + 3 * T;\n    I[P] = A.score, I[P + 1] = A.position.y, I[P + 2] = A.position.x;\n  }\n\n  var y = getScale([r, o], [f, c], s),\n      O = y[0],\n      M = y[1],\n      R = tensor(I, [l, NUM_KEYPOINTS, 3]),\n      b = s.top,\n      C = s.left,\n      x = {\n    variableNames: [\"segmentation\", \"longOffsets\", \"poses\"],\n    outputShape: [h, m],\n    userCode: \"\\n    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {\\n      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));\\n    }\\n\\n    float convertToPositionInOutputFloat(\\n        int pos, int pad, float scale, int stride) {\\n      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);\\n    }\\n\\n    float dist(float x1, float y1, float x2, float y2) {\\n      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);\\n    }\\n\\n    float sampleLongOffsets(float h, float w, int d, int k) {\\n      float fh = fract(h);\\n      float fw = fract(w);\\n      int clH = int(ceil(h));\\n      int clW = int(ceil(w));\\n      int flH = int(floor(h));\\n      int flW = int(floor(w));\\n      float o11 = getLongOffsets(flH, flW, d, k);\\n      float o12 = getLongOffsets(flH, clW, d, k);\\n      float o21 = getLongOffsets(clH, flW, d, k);\\n      float o22 = getLongOffsets(clH, clW, d, k);\\n      float o1 = mix(o11, o12, fw);\\n      float o2 = mix(o21, o22, fw);\\n      return mix(o1, o2, fh);\\n    }\\n\\n    int findNearestPose(int h, int w) {\\n      float prob = getSegmentation(h, w);\\n      if (prob < 1.0) {\\n        return -1;\\n      }\\n\\n      // Done(Tyler): convert from output space h/w to strided space.\\n      float stridedH = convertToPositionInOutputFloat(\\n        h, \" + b + \", \" + M + \", \" + i + \");\\n      float stridedW = convertToPositionInOutputFloat(\\n        w, \" + C + \", \" + O + \", \" + i + \");\\n\\n      float minDist = 1000000.0;\\n      int iMin = -1;\\n      for (int i = 0; i < \" + l + \"; i++) {\\n        float curDistSum = 0.0;\\n        int numKpt = 0;\\n        for (int k = 0; k < \" + NUM_KEYPOINTS + \"; k++) {\\n          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);\\n          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);\\n\\n          float y = float(h) + dy;\\n          float x = float(w) + dx;\\n\\n          for (int s = 0; s < \" + d + \"; s++) {\\n            int yRounded = round(min(y, float(\" + (r - 1) + \")));\\n            int xRounded = round(min(x, float(\" + (o - 1) + \")));\\n\\n            float yStrided = convertToPositionInOutputFloat(\\n              yRounded, \" + b + \", \" + M + \", \" + i + \");\\n            float xStrided = convertToPositionInOutputFloat(\\n              xRounded, \" + C + \", \" + O + \", \" + i + \");\\n\\n            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);\\n            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);\\n\\n            y = y + dy;\\n            x = x + dx;\\n          }\\n\\n          float poseScore = getPoses(i, k, 0);\\n          float poseY = getPoses(i, k, 1);\\n          float poseX = getPoses(i, k, 2);\\n          if (poseScore > \" + u + \") {\\n            numKpt = numKpt + 1;\\n            curDistSum = curDistSum + dist(x, y, poseX, poseY);\\n          }\\n        }\\n        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {\\n          minDist = curDistSum / float(numKpt);\\n          iMin = i;\\n        }\\n      }\\n      return iMin;\\n    }\\n\\n    void main() {\\n        ivec2 coords = getOutputCoords();\\n        int nearestPose = findNearestPose(coords[0], coords[1]);\\n        setOutput(float(nearestPose));\\n      }\\n  \"\n  };\n  return backend().compileAndRun(x, [e, _, R]);\n}\n\nfunction toPersonKSegmentation(e, t) {\n  return tidy(function () {\n    return e.equal(scalar(t)).toInt();\n  });\n}\n\nfunction toPersonKPartSegmentation(e, t, n) {\n  return tidy(function () {\n    return e.equal(scalar(n)).toInt().mul(t.add(1)).sub(1);\n  });\n}\n\nfunction isWebGlBackend() {\n  return \"webgl\" === getBackend();\n}\n\nfunction decodePersonInstanceMasks(e, t, n, r, o, i, a, s, d, u, l, f) {\n  var c = a[0],\n      p = a[1];\n  return void 0 === d && (d = .2), void 0 === u && (u = 8), void 0 === l && (l = .3), void 0 === f && (f = 10), __awaiter(this, void 0, void 0, function () {\n    var a, h, m, g, v;\n    return __generator(this, function (S) {\n      switch (S.label) {\n        case 0:\n          return a = n.filter(function (e) {\n            return e.score >= d;\n          }), isWebGlBackend() ? (m = tidy(function () {\n            var n = decodeMultipleMasksWebGl(e, t, a, r, o, i, [c, p], s, u, l, f);\n            return a.map(function (e, t) {\n              return toPersonKSegmentation(n, t);\n            });\n          }), [4, Promise.all(m.map(function (e) {\n            return e.data();\n          }))]) : [3, 2];\n\n        case 1:\n          return h = S.sent(), m.forEach(function (e) {\n            return e.dispose();\n          }), [3, 5];\n\n        case 2:\n          return [4, e.data()];\n\n        case 3:\n          return g = S.sent(), [4, t.data()];\n\n        case 4:\n          v = S.sent(), h = decodeMultipleMasksCPU(g, v, a, r, o, i, [c, p], s, u), S.label = 5;\n\n        case 5:\n          return [2, h.map(function (e, t) {\n            return {\n              data: e,\n              pose: a[t],\n              width: o,\n              height: r\n            };\n          })];\n      }\n    });\n  });\n}\n\nfunction decodePersonInstancePartMasks(e, t, n, r, o, i, a, s, d, u, l, f, c) {\n  var p = s[0],\n      h = s[1];\n  return void 0 === u && (u = .2), void 0 === l && (l = 8), void 0 === f && (f = .3), void 0 === c && (c = 10), __awaiter(this, void 0, void 0, function () {\n    var s, m, g, v, S, _;\n\n    return __generator(this, function (I) {\n      switch (I.label) {\n        case 0:\n          return s = r.filter(function (e) {\n            return e.score >= u;\n          }), isWebGlBackend() ? (g = tidy(function () {\n            var r = decodeMultipleMasksWebGl(e, t, s, o, i, a, [p, h], d, l, f, c);\n            return s.map(function (e, t) {\n              return toPersonKPartSegmentation(r, n, t);\n            });\n          }), [4, Promise.all(g.map(function (e) {\n            return e.data();\n          }))]) : [3, 2];\n\n        case 1:\n          return m = I.sent(), g.forEach(function (e) {\n            return e.dispose();\n          }), [3, 6];\n\n        case 2:\n          return [4, e.data()];\n\n        case 3:\n          return v = I.sent(), [4, t.data()];\n\n        case 4:\n          return S = I.sent(), [4, n.data()];\n\n        case 5:\n          _ = I.sent(), m = decodeMultiplePartMasksCPU(v, S, _, s, o, i, a, [p, h], d, l), I.label = 6;\n\n        case 6:\n          return [2, m.map(function (e, t) {\n            return {\n              pose: s[t],\n              data: e,\n              height: o,\n              width: i\n            };\n          })];\n      }\n    });\n  });\n}\n\nfunction half(e) {\n  return Math.floor(e / 2);\n}\n\nvar MaxHeap = function () {\n  function e(e, t) {\n    this.priorityQueue = new Array(e), this.numberOfElements = -1, this.getElementValue = t;\n  }\n\n  return e.prototype.enqueue = function (e) {\n    this.priorityQueue[++this.numberOfElements] = e, this.swim(this.numberOfElements);\n  }, e.prototype.dequeue = function () {\n    var e = this.priorityQueue[0];\n    return this.exchange(0, this.numberOfElements--), this.sink(0), this.priorityQueue[this.numberOfElements + 1] = null, e;\n  }, e.prototype.empty = function () {\n    return -1 === this.numberOfElements;\n  }, e.prototype.size = function () {\n    return this.numberOfElements + 1;\n  }, e.prototype.all = function () {\n    return this.priorityQueue.slice(0, this.numberOfElements + 1);\n  }, e.prototype.max = function () {\n    return this.priorityQueue[0];\n  }, e.prototype.swim = function (e) {\n    for (; e > 0 && this.less(half(e), e);) this.exchange(e, half(e)), e = half(e);\n  }, e.prototype.sink = function (e) {\n    for (; 2 * e <= this.numberOfElements;) {\n      var t = 2 * e;\n      if (t < this.numberOfElements && this.less(t, t + 1) && t++, !this.less(e, t)) break;\n      this.exchange(e, t), e = t;\n    }\n  }, e.prototype.getValueAt = function (e) {\n    return this.getElementValue(this.priorityQueue[e]);\n  }, e.prototype.less = function (e, t) {\n    return this.getValueAt(e) < this.getValueAt(t);\n  }, e.prototype.exchange = function (e, t) {\n    var n = this.priorityQueue[e];\n    this.priorityQueue[e] = this.priorityQueue[t], this.priorityQueue[t] = n;\n  }, e;\n}();\n\nfunction scoreIsMaximumInLocalWindow(e, t, n, r, o, i) {\n  for (var a = i.shape, s = a[0], d = a[1], u = !0, l = Math.max(n - o, 0), f = Math.min(n + o + 1, s), c = l; c < f; ++c) {\n    for (var p = Math.max(r - o, 0), h = Math.min(r + o + 1, d), m = p; m < h; ++m) if (i.get(c, m, e) > t) {\n      u = !1;\n      break;\n    }\n\n    if (!u) break;\n  }\n\n  return u;\n}\n\nfunction buildPartWithScoreQueue(e, t, n) {\n  for (var r = n.shape, o = r[0], i = r[1], a = r[2], s = new MaxHeap(o * i * a, function (e) {\n    return e.score;\n  }), d = 0; d < o; ++d) for (var u = 0; u < i; ++u) for (var l = 0; l < a; ++l) {\n    var f = n.get(d, u, l);\n    f < e || scoreIsMaximumInLocalWindow(l, f, d, u, t, n) && s.enqueue({\n      score: f,\n      part: {\n        heatmapY: d,\n        heatmapX: u,\n        id: l\n      }\n    });\n  }\n\n  return s;\n}\n\nvar parentChildrenTuples = POSE_CHAIN.map(function (e) {\n  var t = e[0],\n      n = e[1];\n  return [PART_IDS[t], PART_IDS[n]];\n}),\n    parentToChildEdges = parentChildrenTuples.map(function (e) {\n  return e[1];\n}),\n    childToParentEdges = parentChildrenTuples.map(function (e) {\n  return e[0];\n});\n\nfunction getDisplacement(e, t, n) {\n  var r = n.shape[2] / 2;\n  return {\n    y: n.get(t.y, t.x, e),\n    x: n.get(t.y, t.x, r + e)\n  };\n}\n\nfunction getStridedIndexNearPoint(e, t, n, r) {\n  return {\n    y: clamp(Math.round(e.y / t), 0, n - 1),\n    x: clamp(Math.round(e.x / t), 0, r - 1)\n  };\n}\n\nfunction traverseToTargetKeypoint(e, t, n, r, o, i, a, s) {\n  void 0 === s && (s = 2);\n\n  for (var d = r.shape, u = d[0], l = d[1], f = getDisplacement(e, getStridedIndexNearPoint(t.position, i, u, l), a), c = addVectors(t.position, f), p = 0; p < s; p++) {\n    var h = getStridedIndexNearPoint(c, i, u, l),\n        m = getOffsetPoint(h.y, h.x, n, o);\n    c = addVectors({\n      x: h.x * i,\n      y: h.y * i\n    }, {\n      x: m.x,\n      y: m.y\n    });\n  }\n\n  var g = getStridedIndexNearPoint(c, i, u, l),\n      v = r.get(g.y, g.x, n);\n  return {\n    position: c,\n    part: PART_NAMES[n],\n    score: v\n  };\n}\n\nfunction decodePose(e, t, n, r, o, i) {\n  var a = t.shape[2],\n      s = parentToChildEdges.length,\n      d = new Array(a),\n      u = e.part,\n      l = e.score,\n      f = getImageCoords(u, r, n);\n  d[u.id] = {\n    score: l,\n    part: PART_NAMES[u.id],\n    position: f\n  };\n\n  for (var c = s - 1; c >= 0; --c) {\n    var p = parentToChildEdges[c],\n        h = childToParentEdges[c];\n    d[p] && !d[h] && (d[h] = traverseToTargetKeypoint(c, d[p], h, t, n, r, i));\n  }\n\n  for (c = 0; c < s; ++c) {\n    p = childToParentEdges[c], h = parentToChildEdges[c];\n    d[p] && !d[h] && (d[h] = traverseToTargetKeypoint(c, d[p], h, t, n, r, o));\n  }\n\n  return d;\n}\n\nfunction withinNmsRadiusOfCorrespondingPoint(e, t, n, r) {\n  var o = n.x,\n      i = n.y;\n  return e.some(function (e) {\n    var n = e.keypoints[r].position;\n    return squaredDistance(i, o, n.y, n.x) <= t;\n  });\n}\n\nfunction getInstanceScore(e, t, n) {\n  return n.reduce(function (n, r, o) {\n    var i = r.position,\n        a = r.score;\n    return withinNmsRadiusOfCorrespondingPoint(e, t, i, o) || (n += a), n;\n  }, 0) / n.length;\n}\n\nvar kLocalMaximumRadius = 1;\n\nfunction decodeMultiplePoses(e, t, n, r, o, i, a, s) {\n  void 0 === a && (a = .5), void 0 === s && (s = 20);\n\n  for (var d = [], u = buildPartWithScoreQueue(a, kLocalMaximumRadius, e), l = s * s; d.length < i && !u.empty();) {\n    var f = u.dequeue();\n\n    if (!withinNmsRadiusOfCorrespondingPoint(d, l, getImageCoords(f.part, o, t), f.part.id)) {\n      var c = decodePose(f, e, t, o, n, r),\n          p = getInstanceScore(d, l, c);\n      d.push({\n        keypoints: c,\n        score: p\n      });\n    }\n  }\n\n  return d;\n}\n\nvar _a,\n    imageNetMean = [-123.15, -115.9, -103.06],\n    ResNet = function (e) {\n  function t() {\n    return null !== e && e.apply(this, arguments) || this;\n  }\n\n  return __extends(t, e), t.prototype.preprocessInput = function (e) {\n    return e.add(imageNetMean);\n  }, t.prototype.nameOutputResults = function (e) {\n    var t = e[0],\n        n = e[1],\n        r = e[2],\n        o = e[3],\n        i = e[4],\n        a = e[5];\n    return {\n      offsets: i,\n      segmentation: e[6],\n      partHeatmaps: a,\n      longOffsets: o,\n      heatmap: r,\n      displacementFwd: n,\n      displacementBwd: t,\n      partOffsets: e[7]\n    };\n  }, t;\n}(BaseModel),\n    RESNET50_BASE_URL = \"https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/\",\n    MOBILENET_BASE_URL = \"https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/\";\n\nfunction resNet50SavedModel(e, t) {\n  var n = \"model-stride\" + e + \".json\";\n  return 4 === t ? RESNET50_BASE_URL + \"float/\" + n : RESNET50_BASE_URL + \"quant\" + t + \"/\" + n;\n}\n\nfunction mobileNetSavedModel(e, t, n) {\n  var r = {\n    1: \"100\",\n    .75: \"075\",\n    .5: \"050\"\n  },\n      o = \"model-stride\" + e + \".json\";\n  return 4 === n ? MOBILENET_BASE_URL + \"float/\" + r[t] + \"/\" + o : MOBILENET_BASE_URL + \"quant\" + n + \"/\" + r[t] + \"/\" + o;\n}\n\nfunction getSizeFromImageLikeElement(e) {\n  if (0 !== e.offsetHeight && 0 !== e.offsetWidth) return [e.offsetHeight, e.offsetWidth];\n  if (null != e.height && null != e.width) return [e.height, e.width];\n  throw new Error(\"HTMLImageElement must have height and width attributes set.\");\n}\n\nfunction getSizeFromVideoElement(e) {\n  return null != e.height && null != e.width ? [e.height, e.width] : [e.videoHeight, e.videoWidth];\n}\n\nfunction getInputSize(e) {\n  if (\"undefined\" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || \"undefined\" != typeof HTMLImageElement && e instanceof HTMLImageElement) return getSizeFromImageLikeElement(e);\n  if (\"undefined\" != typeof ImageData && e instanceof ImageData) return [e.height, e.width];\n  if (\"undefined\" != typeof HTMLVideoElement && e instanceof HTMLVideoElement) return getSizeFromVideoElement(e);\n  if (e instanceof Tensor) return [e.shape[0], e.shape[1]];\n  throw new Error(\"error: Unknown input type: \" + e + \".\");\n}\n\nfunction isValidInputResolution(e, t) {\n  return (e - 1) % t == 0;\n}\n\nfunction toValidInputResolution(e, t) {\n  return isValidInputResolution(e, t) ? e : Math.floor(e / t) * t + 1;\n}\n\nvar INTERNAL_RESOLUTION_STRING_OPTIONS = {\n  low: \"low\",\n  medium: \"medium\",\n  high: \"high\",\n  full: \"full\"\n},\n    INTERNAL_RESOLUTION_PERCENTAGES = ((_a = {})[INTERNAL_RESOLUTION_STRING_OPTIONS.low] = .25, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.medium] = .5, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.high] = .75, _a[INTERNAL_RESOLUTION_STRING_OPTIONS.full] = 1, _a),\n    MIN_INTERNAL_RESOLUTION = .1,\n    MAX_INTERNAL_RESOLUTION = 2;\n\nfunction toInternalResolutionPercentage(e) {\n  if (\"string\" == typeof e) {\n    var t = INTERNAL_RESOLUTION_PERCENTAGES[e];\n    return util.assert(\"number\" == typeof t, function () {\n      return \"string value of inputResolution must be one of \" + Object.values(INTERNAL_RESOLUTION_STRING_OPTIONS).join(\",\") + \" but was \" + e + \".\";\n    }), t;\n  }\n\n  return util.assert(\"number\" == typeof e && e <= MAX_INTERNAL_RESOLUTION && e >= MIN_INTERNAL_RESOLUTION, function () {\n    return \"inputResolution must be a string or number between \" + MIN_INTERNAL_RESOLUTION + \" and \" + MAX_INTERNAL_RESOLUTION + \", but was \" + e;\n  }), e;\n}\n\nfunction toInputResolutionHeightAndWidth(e, t, n) {\n  var r = n[0],\n      o = n[1],\n      i = toInternalResolutionPercentage(e);\n  return [toValidInputResolution(r * i, t), toValidInputResolution(o * i, t)];\n}\n\nfunction toInputTensor(e) {\n  return e instanceof Tensor ? e : browser.fromPixels(e);\n}\n\nfunction resizeAndPadTo(e, t, n) {\n  var r = t[0],\n      o = t[1];\n  void 0 === n && (n = !1);\n  var i,\n      a,\n      s,\n      d,\n      u,\n      l,\n      f = e.shape,\n      c = f[0],\n      p = f[1] / c;\n\n  if (p > o / r) {\n    i = o;\n    var h = r - (a = Math.ceil(i / p));\n    s = 0, d = 0, u = Math.floor(h / 2), l = r - (a + u);\n  } else {\n    a = r;\n    var m = o - (i = Math.ceil(r * p));\n    s = Math.floor(m / 2), d = o - (i + s), u = 0, l = 0;\n  }\n\n  return {\n    resizedAndPadded: tidy(function () {\n      var t;\n      return t = n ? e.reverse(1).resizeBilinear([a, i]) : e.resizeBilinear([a, i]), pad3d(t, [[u, l], [s, d], [0, 0]]);\n    }),\n    paddedBy: [[u, l], [s, d]]\n  };\n}\n\nfunction scaleAndCropToInputTensorShape(e, t, n, r, o) {\n  var i = t[0],\n      a = t[1],\n      s = n[0],\n      d = n[1],\n      u = r[0],\n      l = u[0],\n      f = u[1],\n      c = r[1],\n      p = c[0],\n      h = c[1];\n  return void 0 === o && (o = !1), tidy(function () {\n    var t = e.resizeBilinear([s, d], !0);\n    return o && (t = t.sigmoid()), removePaddingAndResizeBack(t, [i, a], [[l, f], [p, h]]);\n  });\n}\n\nfunction removePaddingAndResizeBack(e, t, n) {\n  var r = t[0],\n      o = t[1],\n      i = n[0],\n      a = i[0],\n      s = i[1],\n      d = n[1],\n      u = d[0],\n      l = d[1];\n  return tidy(function () {\n    return image.cropAndResize(e.expandDims(), [[a / (r + a + s - 1), u / (o + u + l - 1), (a + r - 1) / (r + a + s - 1), (u + o - 1) / (o + u + l - 1)]], [0], [r, o]).squeeze([0]);\n  });\n}\n\nfunction padAndResizeTo(e, t) {\n  var n = t[0],\n      r = t[1],\n      o = getInputSize(e),\n      i = o[0],\n      a = o[1],\n      s = r / n,\n      d = [0, 0, 0, 0],\n      u = d[0],\n      l = d[1],\n      f = d[2],\n      c = d[3];\n  return a / i < s ? (u = 0, l = 0, f = Math.round(.5 * (s * i - a)), c = Math.round(.5 * (s * i - a))) : (u = Math.round(.5 * (1 / s * a - i)), l = Math.round(.5 * (1 / s * a - i)), f = 0, c = 0), {\n    resized: tidy(function () {\n      var t = toInputTensor(e);\n      return (t = pad3d(t, [[u, l], [f, c], [0, 0]])).resizeBilinear([n, r]);\n    }),\n    padding: {\n      top: u,\n      left: f,\n      right: c,\n      bottom: l\n    }\n  };\n}\n\nfunction toTensorBuffers3D(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (t) {\n      return [2, Promise.all(e.map(function (e) {\n        return e.buffer();\n      }))];\n    });\n  });\n}\n\nfunction scalePose(e, t, n, r, o) {\n  return void 0 === r && (r = 0), void 0 === o && (o = 0), {\n    score: e.score,\n    keypoints: e.keypoints.map(function (e) {\n      var i = e.score,\n          a = e.part,\n          s = e.position;\n      return {\n        score: i,\n        part: a,\n        position: {\n          x: s.x * n + o,\n          y: s.y * t + r\n        }\n      };\n    })\n  };\n}\n\nfunction scalePoses(e, t, n, r, o) {\n  return void 0 === r && (r = 0), void 0 === o && (o = 0), 1 === n && 1 === t && 0 === r && 0 === o ? e : e.map(function (e) {\n    return scalePose(e, t, n, r, o);\n  });\n}\n\nfunction flipPoseHorizontal(e, t) {\n  return {\n    score: e.score,\n    keypoints: e.keypoints.map(function (e) {\n      var n = e.score,\n          r = e.part,\n          o = e.position;\n      return {\n        score: n,\n        part: r,\n        position: {\n          x: t - 1 - o.x,\n          y: o.y\n        }\n      };\n    })\n  };\n}\n\nfunction flipPosesHorizontal(e, t) {\n  return t <= 0 ? e : e.map(function (e) {\n    return flipPoseHorizontal(e, t);\n  });\n}\n\nfunction scaleAndFlipPoses(e, t, n, r, o) {\n  var i = t[0],\n      a = t[1],\n      s = n[0],\n      d = n[1],\n      u = scalePoses(e, (i + r.top + r.bottom) / s, (a + r.left + r.right) / d, -r.top, -r.left);\n  return o ? flipPosesHorizontal(u, a) : u;\n}\n\nvar APPLY_SIGMOID_ACTIVATION = !0,\n    FLIP_POSES_AFTER_SCALING = !1,\n    MOBILENET_V1_CONFIG = {\n  architecture: \"MobileNetV1\",\n  outputStride: 16,\n  quantBytes: 4,\n  multiplier: .75\n},\n    VALID_ARCHITECTURE = [\"MobileNetV1\", \"ResNet50\"],\n    VALID_STRIDE = {\n  MobileNetV1: [8, 16, 32],\n  ResNet50: [32, 16]\n},\n    VALID_MULTIPLIER = {\n  MobileNetV1: [.5, .75, 1],\n  ResNet50: [1]\n},\n    VALID_QUANT_BYTES = [1, 2, 4];\n\nfunction validateModelConfig(e) {\n  if (null == (e = e || MOBILENET_V1_CONFIG).architecture && (e.architecture = \"MobileNetV1\"), VALID_ARCHITECTURE.indexOf(e.architecture) < 0) throw new Error(\"Invalid architecture \" + e.architecture + \". Should be one of \" + VALID_ARCHITECTURE);\n  if (null == e.outputStride && (e.outputStride = 16), VALID_STRIDE[e.architecture].indexOf(e.outputStride) < 0) throw new Error(\"Invalid outputStride \" + e.outputStride + \". Should be one of \" + VALID_STRIDE[e.architecture] + \" for architecture \" + e.architecture + \".\");\n  if (null == e.multiplier && (e.multiplier = 1), VALID_MULTIPLIER[e.architecture].indexOf(e.multiplier) < 0) throw new Error(\"Invalid multiplier \" + e.multiplier + \". Should be one of \" + VALID_MULTIPLIER[e.architecture] + \" for architecture \" + e.architecture + \".\");\n  if (null == e.quantBytes && (e.quantBytes = 4), VALID_QUANT_BYTES.indexOf(e.quantBytes) < 0) throw new Error(\"Invalid quantBytes \" + e.quantBytes + \". Should be one of \" + VALID_QUANT_BYTES + \" for architecture \" + e.architecture + \".\");\n  return e;\n}\n\nvar PERSON_INFERENCE_CONFIG = {\n  flipHorizontal: !1,\n  internalResolution: \"medium\",\n  segmentationThreshold: .7,\n  maxDetections: 10,\n  scoreThreshold: .4,\n  nmsRadius: 20\n},\n    MULTI_PERSON_INSTANCE_INFERENCE_CONFIG = {\n  flipHorizontal: !1,\n  internalResolution: \"medium\",\n  segmentationThreshold: .7,\n  maxDetections: 10,\n  scoreThreshold: .4,\n  nmsRadius: 20,\n  minKeypointScore: .3,\n  refineSteps: 10\n};\n\nfunction validatePersonInferenceConfig(e) {\n  var t = e.segmentationThreshold,\n      n = e.maxDetections,\n      r = e.scoreThreshold,\n      o = e.nmsRadius;\n  if (t < 0 || t > 1) throw new Error(\"segmentationThreshold \" + t + \". Should be in range [0.0, 1.0]\");\n  if (n <= 0) throw new Error(\"Invalid maxDetections \" + n + \". Should be > 0\");\n  if (r < 0 || r > 1) throw new Error(\"Invalid scoreThreshold \" + r + \". Should be in range [0.0, 1.0]\");\n  if (o <= 0) throw new Error(\"Invalid nmsRadius \" + o + \".\");\n}\n\nfunction validateMultiPersonInstanceInferenceConfig(e) {\n  var t = e.segmentationThreshold,\n      n = e.maxDetections,\n      r = e.scoreThreshold,\n      o = e.nmsRadius,\n      i = e.minKeypointScore,\n      a = e.refineSteps;\n  if (t < 0 || t > 1) throw new Error(\"segmentationThreshold \" + t + \". Should be in range [0.0, 1.0]\");\n  if (n <= 0) throw new Error(\"Invalid maxDetections \" + n + \". Should be > 0\");\n  if (r < 0 || r > 1) throw new Error(\"Invalid scoreThreshold \" + r + \". Should be in range [0.0, 1.0]\");\n  if (o <= 0) throw new Error(\"Invalid nmsRadius \" + o + \".\");\n  if (i < 0 || i > 1) throw new Error(\"Invalid minKeypointScore \" + i + \".Should be in range [0.0, 1.0]\");\n  if (a <= 0 || a > 20) throw new Error(\"Invalid refineSteps \" + a + \".Should be in range [1, 20]\");\n}\n\nvar BodyPix = function () {\n  function e(e) {\n    this.baseModel = e;\n  }\n\n  return e.prototype.predictForPersonSegmentation = function (e) {\n    var t = this.baseModel.predict(e);\n    return {\n      segmentLogits: t.segmentation,\n      heatmapScores: t.heatmapScores,\n      offsets: t.offsets,\n      displacementFwd: t.displacementFwd,\n      displacementBwd: t.displacementBwd\n    };\n  }, e.prototype.predictForPersonSegmentationAndPart = function (e) {\n    var t = this.baseModel.predict(e);\n    return {\n      segmentLogits: t.segmentation,\n      partHeatmapLogits: t.partHeatmaps,\n      heatmapScores: t.heatmapScores,\n      offsets: t.offsets,\n      displacementFwd: t.displacementFwd,\n      displacementBwd: t.displacementBwd\n    };\n  }, e.prototype.predictForMultiPersonInstanceSegmentationAndPart = function (e) {\n    var t = this.baseModel.predict(e);\n    return {\n      segmentLogits: t.segmentation,\n      longOffsets: t.longOffsets,\n      heatmapScores: t.heatmapScores,\n      offsets: t.offsets,\n      displacementFwd: t.displacementFwd,\n      displacementBwd: t.displacementBwd,\n      partHeatmaps: t.partHeatmaps\n    };\n  }, e.prototype.segmentPersonActivation = function (e, t, n) {\n    var r = this;\n    void 0 === n && (n = .5);\n    var o = getInputSize(e),\n        i = o[0],\n        a = o[1],\n        s = toInputResolutionHeightAndWidth(t, this.baseModel.outputStride, [i, a]),\n        d = padAndResizeTo(e, s),\n        u = d.resized,\n        l = d.padding,\n        f = tidy(function () {\n      var e = r.predictForPersonSegmentation(u),\n          t = e.segmentLogits,\n          o = e.heatmapScores,\n          s = e.offsets,\n          d = e.displacementFwd,\n          f = e.displacementBwd,\n          c = u.shape,\n          p = c[0],\n          h = c[1];\n      return {\n        segmentation: toMaskTensor(scaleAndCropToInputTensorShape(t, [i, a], [p, h], [[l.top, l.bottom], [l.left, l.right]], APPLY_SIGMOID_ACTIVATION).squeeze(), n),\n        heatmapScores: o,\n        offsets: s,\n        displacementFwd: d,\n        displacementBwd: f\n      };\n    }),\n        c = f.segmentation,\n        p = f.heatmapScores,\n        h = f.offsets,\n        m = f.displacementFwd,\n        g = f.displacementBwd;\n    return u.dispose(), {\n      segmentation: c,\n      heatmapScores: p,\n      offsets: h,\n      displacementFwd: m,\n      displacementBwd: g,\n      padding: l,\n      internalResolutionHeightAndWidth: s\n    };\n  }, e.prototype.segmentPerson = function (e, t) {\n    return void 0 === t && (t = PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n, r, o, i, a, s, d, u, l, f, c, p, h, m, g, v, S, _;\n\n      return __generator(this, function (I) {\n        switch (I.label) {\n          case 0:\n            return validatePersonInferenceConfig(t = __assign({}, PERSON_INFERENCE_CONFIG, t)), n = this.segmentPersonActivation(e, t.internalResolution, t.segmentationThreshold), r = n.segmentation, o = n.heatmapScores, i = n.offsets, a = n.displacementFwd, s = n.displacementBwd, d = n.padding, u = n.internalResolutionHeightAndWidth, l = r.shape, f = l[0], c = l[1], [4, r.data()];\n\n          case 1:\n            return p = I.sent(), r.dispose(), [4, toTensorBuffers3D([o, i, a, s])];\n\n          case 2:\n            return h = I.sent(), m = h[0], g = h[1], v = h[2], S = h[3], _ = scaleAndFlipPoses(_ = decodeMultiplePoses(m, g, v, S, this.baseModel.outputStride, t.maxDetections, t.scoreThreshold, t.nmsRadius), [f, c], u, d, FLIP_POSES_AFTER_SCALING), o.dispose(), i.dispose(), a.dispose(), s.dispose(), [2, {\n              height: f,\n              width: c,\n              data: p,\n              allPoses: _\n            }];\n        }\n      });\n    });\n  }, e.prototype.segmentMultiPerson = function (e, t) {\n    return void 0 === t && (t = MULTI_PERSON_INSTANCE_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n,\n          r,\n          o,\n          i,\n          a,\n          s,\n          d,\n          u,\n          l,\n          f,\n          c,\n          p,\n          h,\n          m,\n          g,\n          v,\n          S,\n          _,\n          I,\n          w,\n          E,\n          N = this;\n\n      return __generator(this, function (T) {\n        switch (T.label) {\n          case 0:\n            return validateMultiPersonInstanceInferenceConfig(t = __assign({}, MULTI_PERSON_INSTANCE_INFERENCE_CONFIG, t)), n = getInputSize(e), r = n[0], o = n[1], i = toInputResolutionHeightAndWidth(t.internalResolution, this.baseModel.outputStride, [r, o]), a = padAndResizeTo(e, i), s = a.resized, d = a.padding, u = tidy(function () {\n              var e,\n                  n = N.predictForMultiPersonInstanceSegmentationAndPart(s),\n                  a = n.segmentLogits,\n                  u = n.longOffsets,\n                  l = n.heatmapScores,\n                  f = n.offsets,\n                  c = n.displacementFwd,\n                  p = n.displacementBwd;\n              return e = u, {\n                segmentation: toMaskTensor(scaleAndCropToInputTensorShape(a, [r, o], i, [[d.top, d.bottom], [d.left, d.right]], APPLY_SIGMOID_ACTIVATION).squeeze(), t.segmentationThreshold),\n                longOffsets: e,\n                heatmapScoresRaw: l,\n                offsetsRaw: f,\n                displacementFwdRaw: c,\n                displacementBwdRaw: p\n              };\n            }), l = u.segmentation, f = u.longOffsets, c = u.heatmapScoresRaw, p = u.offsetsRaw, h = u.displacementFwdRaw, m = u.displacementBwdRaw, [4, toTensorBuffers3D([c, p, h, m])];\n\n          case 1:\n            return g = T.sent(), v = g[0], S = g[1], _ = g[2], I = g[3], w = scaleAndFlipPoses(w = decodeMultiplePoses(v, S, _, I, this.baseModel.outputStride, t.maxDetections, t.scoreThreshold, t.nmsRadius), [r, o], i, d, FLIP_POSES_AFTER_SCALING), [4, decodePersonInstanceMasks(l, f, w, r, o, this.baseModel.outputStride, i, d, t.scoreThreshold, t.refineSteps, t.minKeypointScore, t.maxDetections)];\n\n          case 2:\n            return E = T.sent(), s.dispose(), l.dispose(), f.dispose(), c.dispose(), p.dispose(), h.dispose(), m.dispose(), [2, E];\n        }\n      });\n    });\n  }, e.prototype.segmentPersonPartsActivation = function (e, t, n) {\n    var r = this;\n    void 0 === n && (n = .5);\n    var o = getInputSize(e),\n        i = o[0],\n        a = o[1],\n        s = toInputResolutionHeightAndWidth(t, this.baseModel.outputStride, [i, a]),\n        d = padAndResizeTo(e, s),\n        u = d.resized,\n        l = d.padding,\n        f = tidy(function () {\n      var e = r.predictForPersonSegmentationAndPart(u),\n          t = e.segmentLogits,\n          o = e.partHeatmapLogits,\n          s = e.heatmapScores,\n          d = e.offsets,\n          f = e.displacementFwd,\n          c = e.displacementBwd,\n          p = u.shape,\n          h = p[0],\n          m = p[1],\n          g = scaleAndCropToInputTensorShape(t, [i, a], [h, m], [[l.top, l.bottom], [l.left, l.right]], APPLY_SIGMOID_ACTIVATION),\n          v = scaleAndCropToInputTensorShape(o, [i, a], [h, m], [[l.top, l.bottom], [l.left, l.right]], APPLY_SIGMOID_ACTIVATION);\n      return {\n        partSegmentation: decodePartSegmentation(toMaskTensor(g.squeeze(), n), v),\n        heatmapScores: s,\n        offsets: d,\n        displacementFwd: f,\n        displacementBwd: c\n      };\n    }),\n        c = f.partSegmentation,\n        p = f.heatmapScores,\n        h = f.offsets,\n        m = f.displacementFwd,\n        g = f.displacementBwd;\n    return u.dispose(), {\n      partSegmentation: c,\n      heatmapScores: p,\n      offsets: h,\n      displacementFwd: m,\n      displacementBwd: g,\n      padding: l,\n      internalResolutionHeightAndWidth: s\n    };\n  }, e.prototype.segmentPersonParts = function (e, t) {\n    return void 0 === t && (t = PERSON_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n, r, o, i, a, s, d, u, l, f, c, p, h, m, g, v, S, _;\n\n      return __generator(this, function (I) {\n        switch (I.label) {\n          case 0:\n            return validatePersonInferenceConfig(t = __assign({}, PERSON_INFERENCE_CONFIG, t)), n = this.segmentPersonPartsActivation(e, t.internalResolution, t.segmentationThreshold), r = n.partSegmentation, o = n.heatmapScores, i = n.offsets, a = n.displacementFwd, s = n.displacementBwd, d = n.padding, u = n.internalResolutionHeightAndWidth, l = r.shape, f = l[0], c = l[1], [4, r.data()];\n\n          case 1:\n            return p = I.sent(), r.dispose(), [4, toTensorBuffers3D([o, i, a, s])];\n\n          case 2:\n            return h = I.sent(), m = h[0], g = h[1], v = h[2], S = h[3], _ = scaleAndFlipPoses(_ = decodeMultiplePoses(m, g, v, S, this.baseModel.outputStride, t.maxDetections, t.scoreThreshold, t.nmsRadius), [f, c], u, d, FLIP_POSES_AFTER_SCALING), o.dispose(), i.dispose(), a.dispose(), s.dispose(), [2, {\n              height: f,\n              width: c,\n              data: p,\n              allPoses: _\n            }];\n        }\n      });\n    });\n  }, e.prototype.segmentMultiPersonParts = function (e, t) {\n    return void 0 === t && (t = MULTI_PERSON_INSTANCE_INFERENCE_CONFIG), __awaiter(this, void 0, void 0, function () {\n      var n,\n          r,\n          o,\n          i,\n          a,\n          s,\n          d,\n          u,\n          l,\n          f,\n          c,\n          p,\n          h,\n          m,\n          g,\n          v,\n          S,\n          _,\n          I,\n          w,\n          E,\n          N,\n          T = this;\n\n      return __generator(this, function (A) {\n        switch (A.label) {\n          case 0:\n            return validateMultiPersonInstanceInferenceConfig(t = __assign({}, MULTI_PERSON_INSTANCE_INFERENCE_CONFIG, t)), n = getInputSize(e), r = n[0], o = n[1], i = toInputResolutionHeightAndWidth(t.internalResolution, this.baseModel.outputStride, [r, o]), a = padAndResizeTo(e, i), s = a.resized, d = a.padding, u = tidy(function () {\n              var e = T.predictForMultiPersonInstanceSegmentationAndPart(s),\n                  n = e.segmentLogits,\n                  a = e.longOffsets,\n                  u = e.heatmapScores,\n                  l = e.offsets,\n                  f = e.displacementFwd,\n                  c = e.displacementBwd,\n                  p = e.partHeatmaps,\n                  h = scaleAndCropToInputTensorShape(n, [r, o], i, [[d.top, d.bottom], [d.left, d.right]], APPLY_SIGMOID_ACTIVATION),\n                  m = scaleAndCropToInputTensorShape(p, [r, o], i, [[d.top, d.bottom], [d.left, d.right]], APPLY_SIGMOID_ACTIVATION),\n                  g = a;\n              return {\n                segmentation: toMaskTensor(h.squeeze(), t.segmentationThreshold),\n                longOffsets: g,\n                heatmapScoresRaw: u,\n                offsetsRaw: l,\n                displacementFwdRaw: f,\n                displacementBwdRaw: c,\n                partSegmentation: decodeOnlyPartSegmentation(m)\n              };\n            }), l = u.segmentation, f = u.longOffsets, c = u.heatmapScoresRaw, p = u.offsetsRaw, h = u.displacementFwdRaw, m = u.displacementBwdRaw, g = u.partSegmentation, [4, toTensorBuffers3D([c, p, h, m])];\n\n          case 1:\n            return v = A.sent(), S = v[0], _ = v[1], I = v[2], w = v[3], E = scaleAndFlipPoses(E = decodeMultiplePoses(S, _, I, w, this.baseModel.outputStride, t.maxDetections, t.scoreThreshold, t.nmsRadius), [r, o], i, d, FLIP_POSES_AFTER_SCALING), [4, decodePersonInstancePartMasks(l, f, g, E, r, o, this.baseModel.outputStride, i, d, t.scoreThreshold, t.refineSteps, t.minKeypointScore, t.maxDetections)];\n\n          case 2:\n            return N = A.sent(), s.dispose(), l.dispose(), f.dispose(), c.dispose(), p.dispose(), h.dispose(), m.dispose(), g.dispose(), [2, N];\n        }\n      });\n    });\n  }, e.prototype.dispose = function () {\n    this.baseModel.dispose();\n  }, e;\n}();\n\nfunction loadMobileNet(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, n, r, o, i, a;\n    return __generator(this, function (s) {\n      switch (s.label) {\n        case 0:\n          if (t = e.outputStride, n = e.quantBytes, r = e.multiplier, null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\\n        model.\");\n          return o = mobileNetSavedModel(t, r, n), [4, loadGraphModel(e.modelUrl || o)];\n\n        case 1:\n          return i = s.sent(), a = new MobileNet(i, t), [2, new BodyPix(a)];\n      }\n    });\n  });\n}\n\nfunction loadResNet(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, n, r, o, i;\n    return __generator(this, function (a) {\n      switch (a.label) {\n        case 0:\n          if (t = e.outputStride, n = e.quantBytes, null == tf) throw new Error(\"Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\\n        model.\");\n          return r = resNet50SavedModel(t, n), [4, loadGraphModel(e.modelUrl || r)];\n\n        case 1:\n          return o = a.sent(), i = new ResNet(o, t), [2, new BodyPix(i)];\n      }\n    });\n  });\n}\n\nfunction load(e) {\n  return void 0 === e && (e = MOBILENET_V1_CONFIG), __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (t) {\n      return \"ResNet50\" === (e = validateModelConfig(e)).architecture ? [2, loadResNet(e)] : \"MobileNetV1\" === e.architecture ? [2, loadMobileNet(e)] : [2, null];\n    });\n  });\n}\n\nfunction cpuBlur(e, t, n) {\n  for (var r = e.getContext(\"2d\"), o = 0, i = 1 / (2 * Math.PI * 5 * 5), a = n < 3 ? 1 : 2, s = -n; s <= n; s += a) for (var d = -n; d <= n; d += a) {\n    o += i * Math.exp(-(d * d + s * s) / 50);\n  }\n\n  for (s = -n; s <= n; s += a) for (d = -n; d <= n; d += a) r.globalAlpha = i * Math.exp(-(d * d + s * s) / 50) / o * n, r.drawImage(t, d, s);\n\n  r.globalAlpha = 1;\n}\n\nvar offScreenCanvases = {};\n\nfunction isSafari() {\n  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\n\nfunction assertSameDimensions(e, t, n, r) {\n  var o = e.width,\n      i = e.height,\n      a = t.width,\n      s = t.height;\n  if (o !== a || i !== s) throw new Error(\"error: dimensions must match. \" + n + \" has dimensions \" + o + \"x\" + i + \", \" + r + \" has dimensions \" + a + \"x\" + s);\n}\n\nfunction flipCanvasHorizontal(e) {\n  var t = e.getContext(\"2d\");\n  t.scale(-1, 1), t.translate(-e.width, 0);\n}\n\nfunction drawWithCompositing(e, t, n) {\n  e.globalCompositeOperation = n, e.drawImage(t, 0, 0);\n}\n\nfunction createOffScreenCanvas() {\n  return document.createElement(\"canvas\");\n}\n\nfunction ensureOffscreenCanvasCreated(e) {\n  return offScreenCanvases[e] || (offScreenCanvases[e] = createOffScreenCanvas()), offScreenCanvases[e];\n}\n\nfunction drawAndBlurImageOnCanvas(e, t, n) {\n  var r = e.height,\n      o = e.width,\n      i = n.getContext(\"2d\");\n  n.width = o, n.height = r, i.clearRect(0, 0, o, r), i.save(), isSafari() ? cpuBlur(n, e, t) : (i.filter = \"blur(\" + t + \"px)\", i.drawImage(e, 0, 0, o, r)), i.restore();\n}\n\nfunction drawAndBlurImageOnOffScreenCanvas(e, t, n) {\n  var r = ensureOffscreenCanvasCreated(n);\n  return 0 === t ? renderImageToCanvas(e, r) : drawAndBlurImageOnCanvas(e, t, r), r;\n}\n\nfunction renderImageToCanvas(e, t) {\n  var n = e.width,\n      r = e.height;\n  t.width = n, t.height = r, t.getContext(\"2d\").drawImage(e, 0, 0, n, r);\n}\n\nfunction renderImageDataToCanvas(e, t) {\n  t.width = e.width, t.height = e.height, t.getContext(\"2d\").putImageData(e, 0, 0);\n}\n\nfunction renderImageDataToOffScreenCanvas(e, t) {\n  var n = ensureOffscreenCanvasCreated(t);\n  return renderImageDataToCanvas(e, n), n;\n}\n\nfunction toMask(e, t, n, r, o) {\n  if (void 0 === t && (t = {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 0\n  }), void 0 === n && (n = {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 255\n  }), void 0 === r && (r = !1), void 0 === o && (o = [1]), Array.isArray(e) && 0 === e.length) return null;\n  var i,\n      a = (i = Array.isArray(e) ? e : [e])[0],\n      s = a.width,\n      d = a.height,\n      u = new Uint8ClampedArray(s * d * 4);\n\n  function l(e, t, n, r, o, i) {\n    void 0 === i && (i = {\n      r: 0,\n      g: 255,\n      b: 255,\n      a: 255\n    });\n\n    for (var a = -o; a <= o; a++) for (var s = -o; s <= o; s++) if (0 !== a && 0 !== s) {\n      var d = (t + a) * r + (n + s);\n      e[4 * d + 0] = i.r, e[4 * d + 1] = i.g, e[4 * d + 2] = i.b, e[4 * d + 3] = i.a;\n    }\n  }\n\n  function f(e, t, n, r, o, i) {\n    void 0 === o && (o = [1]), void 0 === i && (i = 1);\n\n    for (var a = 0, s = -i; s <= i; s++) for (var d = function (i) {\n      if (0 !== s && 0 !== i) {\n        var d = (t + s) * r + (n + i);\n        o.some(function (t) {\n          return t === e[d];\n        }) || (a += 1);\n      }\n    }, u = -i; u <= i; u++) d(u);\n\n    return a > 0;\n  }\n\n  for (var c = 0; c < d; c += 1) for (var p = function (e) {\n    var a = c * s + e;\n    u[4 * a + 0] = n.r, u[4 * a + 1] = n.g, u[4 * a + 2] = n.b, u[4 * a + 3] = n.a;\n\n    for (var p = function (n) {\n      if (o.some(function (e) {\n        return e === i[n].data[a];\n      })) {\n        u[4 * a] = t.r, u[4 * a + 1] = t.g, u[4 * a + 2] = t.b, u[4 * a + 3] = t.a;\n        var p = f(i[n].data, c, e, s, o);\n        r && c - 1 >= 0 && c + 1 < d && e - 1 >= 0 && e + 1 < s && p && l(u, c, e, s, 1);\n      }\n    }, h = 0; h < i.length; h++) p(h);\n  }, h = 0; h < s; h += 1) p(h);\n\n  return new ImageData(u, s, d);\n}\n\nvar RAINBOW_PART_COLORS = [[110, 64, 170], [143, 61, 178], [178, 60, 178], [210, 62, 167], [238, 67, 149], [255, 78, 125], [255, 94, 99], [255, 115, 75], [255, 140, 56], [239, 167, 47], [217, 194, 49], [194, 219, 64], [175, 240, 91], [135, 245, 87], [96, 247, 96], [64, 243, 115], [40, 234, 141], [28, 219, 169], [26, 199, 194], [33, 176, 213], [47, 150, 224], [65, 125, 224], [84, 101, 214], [99, 81, 195]];\n\nfunction toColoredPartMask(e, t) {\n  if (void 0 === t && (t = RAINBOW_PART_COLORS), Array.isArray(e) && 0 === e.length) return null;\n\n  for (var n, r = (n = Array.isArray(e) ? e : [e])[0], o = r.width, i = r.height, a = new Uint8ClampedArray(o * i * 4), s = 0; s < i * o; ++s) {\n    var d = 4 * s;\n    a[d + 0] = 255, a[d + 1] = 255, a[d + 2] = 255, a[d + 3] = 255;\n\n    for (var u = 0; u < n.length; u++) {\n      var l = n[u].data[s];\n\n      if (-1 !== l) {\n        var f = t[l];\n        if (!f) throw new Error(\"No color could be found for part id \" + l);\n        a[d + 0] = f[0], a[d + 1] = f[1], a[d + 2] = f[2], a[d + 3] = 255;\n      }\n    }\n  }\n\n  return new ImageData(a, o, i);\n}\n\nvar CANVAS_NAMES = {\n  blurred: \"blurred\",\n  blurredMask: \"blurred-mask\",\n  mask: \"mask\",\n  lowresPartMask: \"lowres-part-mask\"\n};\n\nfunction drawMask(e, t, n, r, o, i) {\n  void 0 === r && (r = .7), void 0 === o && (o = 0), void 0 === i && (i = !1);\n  var a = getInputSize(t),\n      s = a[0],\n      d = a[1];\n  e.width = d, e.height = s;\n  var u = e.getContext(\"2d\");\n\n  if (u.save(), i && flipCanvasHorizontal(e), u.drawImage(t, 0, 0), u.globalAlpha = r, n) {\n    assertSameDimensions({\n      width: d,\n      height: s\n    }, n, \"image\", \"mask\");\n    var l = drawAndBlurImageOnOffScreenCanvas(renderImageDataToOffScreenCanvas(n, CANVAS_NAMES.mask), o, CANVAS_NAMES.blurredMask);\n    u.drawImage(l, 0, 0, d, s);\n  }\n\n  u.restore();\n}\n\nfunction drawPixelatedMask(e, t, n, r, o, i, a) {\n  void 0 === r && (r = .7), void 0 === o && (o = 0), void 0 === i && (i = !1), void 0 === a && (a = 10);\n  var s = getInputSize(t),\n      d = s[0];\n  assertSameDimensions({\n    width: s[1],\n    height: d\n  }, n, \"image\", \"mask\");\n  var u = drawAndBlurImageOnOffScreenCanvas(renderImageDataToOffScreenCanvas(n, CANVAS_NAMES.mask), o, CANVAS_NAMES.blurredMask);\n  e.width = u.width, e.height = u.height;\n  var l = e.getContext(\"2d\");\n  l.save(), i && flipCanvasHorizontal(e);\n  var f = ensureOffscreenCanvasCreated(CANVAS_NAMES.lowresPartMask),\n      c = f.getContext(\"2d\");\n  f.width = u.width * (1 / a), f.height = u.height * (1 / a), c.drawImage(u, 0, 0, u.width, u.height, 0, 0, f.width, f.height), l.imageSmoothingEnabled = !1, l.drawImage(f, 0, 0, f.width, f.height, 0, 0, e.width, e.height);\n\n  for (var p = 0; p < f.width; p++) l.beginPath(), l.strokeStyle = \"#ffffff\", l.moveTo(a * p, 0), l.lineTo(a * p, e.height), l.stroke();\n\n  for (p = 0; p < f.height; p++) l.beginPath(), l.strokeStyle = \"#ffffff\", l.moveTo(0, a * p), l.lineTo(e.width, a * p), l.stroke();\n\n  l.globalAlpha = 1 - r, l.drawImage(t, 0, 0, u.width, u.height), l.restore();\n}\n\nfunction createPersonMask(e, t) {\n  var n = renderImageDataToOffScreenCanvas(toMask(e, {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 255\n  }, {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 0\n  }), CANVAS_NAMES.mask);\n  return 0 === t ? n : drawAndBlurImageOnOffScreenCanvas(n, t, CANVAS_NAMES.blurredMask);\n}\n\nfunction drawBokehEffect(e, t, n, r, o, i) {\n  void 0 === r && (r = 3), void 0 === o && (o = 3), void 0 === i && (i = !1);\n  var a = drawAndBlurImageOnOffScreenCanvas(t, r, CANVAS_NAMES.blurred);\n  e.width = a.width, e.height = a.height;\n  var s = e.getContext(\"2d\");\n  if (Array.isArray(n) && 0 === n.length) s.drawImage(a, 0, 0);else {\n    var d = createPersonMask(n, o);\n    s.save(), i && flipCanvasHorizontal(e);\n    var u = getInputSize(t),\n        l = u[0],\n        f = u[1];\n    s.drawImage(t, 0, 0, f, l), drawWithCompositing(s, d, \"destination-in\"), drawWithCompositing(s, a, \"destination-over\"), s.restore();\n  }\n}\n\nfunction createBodyPartMask(e, t, n) {\n  var r = renderImageDataToOffScreenCanvas(toMask(e, {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 0\n  }, {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 255\n  }, !0, t), CANVAS_NAMES.mask);\n  return 0 === n ? r : drawAndBlurImageOnOffScreenCanvas(r, n, CANVAS_NAMES.blurredMask);\n}\n\nfunction blurBodyPart(e, t, n, r, o, i, a) {\n  void 0 === r && (r = [0, 1]), void 0 === o && (o = 3), void 0 === i && (i = 3), void 0 === a && (a = !1);\n  var s = drawAndBlurImageOnOffScreenCanvas(t, o, CANVAS_NAMES.blurred);\n  e.width = s.width, e.height = s.height;\n  var d = e.getContext(\"2d\");\n  if (Array.isArray(n) && 0 === n.length) d.drawImage(s, 0, 0);else {\n    var u = createBodyPartMask(n, r, i);\n    d.save(), a && flipCanvasHorizontal(e);\n    var l = getInputSize(t),\n        f = l[0],\n        c = l[1];\n    d.drawImage(t, 0, 0, c, f), drawWithCompositing(d, u, \"destination-in\"), drawWithCompositing(d, s, \"destination-over\"), d.restore();\n  }\n}\n\nvar PART_CHANNELS = [\"left_face\", \"right_face\", \"left_upper_arm_front\", \"left_upper_arm_back\", \"right_upper_arm_front\", \"right_upper_arm_back\", \"left_lower_arm_front\", \"left_lower_arm_back\", \"right_lower_arm_front\", \"right_lower_arm_back\", \"left_hand\", \"right_hand\", \"torso_front\", \"torso_back\", \"left_upper_leg_front\", \"left_upper_leg_back\", \"right_upper_leg_front\", \"right_upper_leg_back\", \"left_lower_leg_front\", \"left_lower_leg_back\", \"right_lower_leg_front\", \"right_lower_leg_back\", \"left_feet\", \"right_feet\"],\n    version = \"2.0.5\";\nexport { BodyPix, load, blurBodyPart, drawBokehEffect, drawMask, drawPixelatedMask, toColoredPartMask, toMask, PART_CHANNELS, flipPoseHorizontal, resizeAndPadTo, scaleAndCropToInputTensorShape, version };","map":{"version":3,"sources":["../src/decode_part_map.ts","../src/base_model.ts","../src/mobilenet.ts","../src/keypoints.ts","../src/multi_person/util.ts","../src/multi_person/decode_multiple_masks_cpu.ts","../src/multi_person/decode_multiple_masks_webgl.ts","../src/multi_person/decode_instance_masks.ts","../src/multi_person/max_heap.ts","../src/multi_person/build_part_with_score_queue.ts","../src/multi_person/decode_pose.ts","../src/multi_person/decode_multiple_poses.ts","../src/resnet.ts","../src/saved_models.ts","../src/util.ts","../src/body_pix_model.ts","../src/blur.ts","../src/output_rendering_util.ts","../src/part_channels.ts","../src/version.ts"],"names":["toFlattenedOneHotPartMap","partHeatmapScores","numParts","shape","argMax","partMapFlattened","reshape","tf.oneHot","clipByMask2d","image","mask","mul","toMaskTensor","segmentScores","threshold","tf.tidy","greater","tf.scalar","toInt","decodePartSegmentation","segmentationMask","partMapHeight","partMapWidth","flattenedMap","partNumbers","tf.range","expandDims","matMul","add","sub","decodeOnlyPartSegmentation","model","outputStride","inputShape","this","inputs","tf.util","assert","BaseModel","input","_this","preprocessInput","toFloat","asBatch","predict","results3d","map","squeeze","namedResults","nameOutputResults","heatmapScores","heatmap","sigmoid","offsets","displacementFwd","displacementBwd","segmentation","partHeatmaps","longOffsets","partOffsets","dispose","tslib_1.__extends","MobileNet","results","PART_NAMES","NUM_KEYPOINTS","length","PART_IDS","reduce","result","jointName","i","CONNECTED_PART_NAMES","POSE_CHAIN","CONNECTED_PART_INDICES","_a","jointNameA","jointNameB","getScale","height","width","_b","inputResolutionY","inputResolutionX","padding","padT","padB","getOffsetPoint","y","x","keypoint","get","getImageCoords","part","heatmapX","heatmapY","clamp","a","min","max","squaredDistance","y1","x1","y2","x2","dy","dx","addVectors","b","computeDistance","embedding","pose","minPartScore","distance","numKpt","p","keypoints","score","Math","position","Infinity","convertToPositionInOuput","padL","scaleX","scaleY","stride","round","getEmbedding","location","keypointIndex","convertToPosition","outputResolutionX","refineSteps","newLocation","nn","t","newPos","nn_1","matchEmbeddingToInstance","poses","numKptForMatching","_c","embed","pair","keypointsIndex","push","kMin","kMinDist","k","dist","getOutputResolution","decodeMultipleMasksCPU","posesAboveScore","inHeight","inWidth","dataArrays","Uint8Array","fill","j","n","decodeMultiplePartMasksCPU","partSegmentaion","Int32Array","decodeMultipleMasksWebGl","minKptScore","maxNumPeople","origHeight","origWidth","outHeight","outWidth","shapedLongOffsets","poseVals","Float32Array","poseOffset","kp","offset","posesTensor","tf.tensor","program","variableNames","outputShape","userCode","tf.backend","compileAndRun","toPersonKSegmentation","equal","toPersonKPartSegmentation","bodyParts","isWebGlBackend","getBackend","decodePersonInstanceMasks","minPoseScore","minKeypointScore","filter","personSegmentations","masksTensor","_","personSegmentationsData","Promise","all","data","forEach","segmentationsData","longOffsetsData","decodePersonInstancePartMasks","partSegmentation","partSegmentations","partSegmentationsByPersonData","partSegmentaionData","half","floor","maxSize","getElementValue","priorityQueue","Array","numberOfElements","MaxHeap","swim","exchange","sink","slice","less","getValueAt","scoreIsMaximumInLocalWindow","keypointId","localMaximumRadius","scores","localMaximum","yStart","yEnd","yCurrent","xStart","xEnd","xCurrent","buildPartWithScoreQueue","scoreThreshold","numKeypoints","queue","enqueue","id","parentChildrenTuples","parentJoinName","childJoinName","parentToChildEdges","childToParentEdges","getDisplacement","edgeId","point","displacements","numEdges","getStridedIndexNearPoint","traverseToTargetKeypoint","sourceKeypoint","targetKeypointId","scoresBuffer","offsetRefineStep","displacement","targetKeypoint","targetKeypointIndices","offsetPoint","targetKeyPointIndices","decodePose","root","displacementsFwd","displacementsBwd","instanceKeypoints","rootPart","rootScore","rootPoint","edge","sourceKeypointId","withinNmsRadiusOfCorrespondingPoint","squaredNmsRadius","some","correspondingKeypoint","getInstanceScore","existingPoses","kLocalMaximumRadius","decodeMultiplePoses","offsetsBuffer","displacementsFwdBuffer","displacementsBwdBuffer","maxPoseDetections","nmsRadius","empty","dequeue","imageNetMean","ResNet","RESNET50_BASE_URL","MOBILENET_BASE_URL","resNet50SavedModel","quantBytes","graphJson","mobileNetSavedModel","multiplier","toStr","1","0.75","0.5","getSizeFromImageLikeElement","offsetHeight","offsetWidth","Error","getSizeFromVideoElement","videoHeight","videoWidth","getInputSize","HTMLCanvasElement","HTMLImageElement","ImageData","HTMLVideoElement","tf.Tensor","isValidInputResolution","resolution","toValidInputResolution","inputResolution","INTERNAL_RESOLUTION_STRING_OPTIONS","low","medium","high","full","INTERNAL_RESOLUTION_PERCENTAGES","MIN_INTERNAL_RESOLUTION","MAX_INTERNAL_RESOLUTION","toInternalResolutionPercentage","internalResolution","Object","values","join","toInputResolutionHeightAndWidth","inputHeight","inputWidth","internalResolutionPercentage","toInputTensor","tf.browser","fromPixels","resizeAndPadTo","imageTensor","targetH","targetW","flipHorizontal","aspect","resizeW","resizeH","padR","ceil","padHeight","padWidth","resized","reverse","resizeBilinear","tf.pad3d","resizedAndPadded","paddedBy","scaleAndCropToInputTensorShape","tensor","inputTensorHeight","inputTensorWidth","resizedAndPaddedHeight","resizedAndPaddedWidth","_d","_e","applySigmoidActivation","inResizedAndPadded","removePaddingAndResizeBack","originalHeight","originalWidth","tf.image","cropAndResize","padAndResizeTo","targetAspect","top","left","right","bottom","toTensorBuffers3D","tensors","buffer","scalePose","offsetY","offsetX","scalePoses","flipPoseHorizontal","imageWidth","flipPosesHorizontal","scaleAndFlipPoses","inputResolutionHeight","inputResolutionWidth","scaledPoses","APPLY_SIGMOID_ACTIVATION","FLIP_POSES_AFTER_SCALING","MOBILENET_V1_CONFIG","architecture","VALID_ARCHITECTURE","VALID_STRIDE","MobileNetV1","ResNet50","VALID_MULTIPLIER","VALID_QUANT_BYTES","validateModelConfig","config","indexOf","PERSON_INFERENCE_CONFIG","segmentationThreshold","maxDetections","MULTI_PERSON_INSTANCE_INFERENCE_CONFIG","validatePersonInferenceConfig","validateMultiPersonInstanceInferenceConfig","net","baseModel","BodyPix","segmentLogits","partHeatmapLogits","internalResolutionHeightAndWidth","segmentPersonActivation","scoresBuf","offsetsBuf","displacementsFwdBuf","displacementsBwdBuf","allPoses","heatmapScoresRaw","offsetsRaw","displacementFwdRaw","displacementBwdRaw","scaledLongOffsets","instanceMasks","segmentPersonPartsActivation","scaledSegmentScores","scaledPartSegmentationScores","loadMobileNet","tf","url","graphModel","tfconv.loadGraphModel","modelUrl","mobilenet","loadResNet","resnet","load","cpuBlur","canvas","blur","ctx","getContext","sum","alphaLeft","PI","step","exp","globalAlpha","drawImage","offScreenCanvases","isSafari","test","navigator","userAgent","assertSameDimensions","widthA","heightA","widthB","heightB","nameA","nameB","flipCanvasHorizontal","scale","translate","drawWithCompositing","compositOperation","globalCompositeOperation","createOffScreenCanvas","document","createElement","ensureOffscreenCanvasCreated","drawAndBlurImageOnCanvas","blurAmount","clearRect","save","restore","drawAndBlurImageOnOffScreenCanvas","offscreenCanvasName","renderImageToCanvas","renderImageDataToCanvas","putImageData","renderImageDataToOffScreenCanvas","canvasName","toMask","personOrPartSegmentation","foreground","r","g","background","drawContour","foregroundIds","isArray","multiPersonOrPartSegmentation","bytes","Uint8ClampedArray","drawStroke","row","column","radius","color","isSegmentationBoundary","segmentationData","numberBackgroundPixels","n_1","isBoundary","RAINBOW_PART_COLORS","toColoredPartMask","partColors","multiPersonPartSegmentation","partId","CANVAS_NAMES","blurred","blurredMask","lowresPartMask","drawMask","maskImage","maskOpacity","maskBlurAmount","drawPixelatedMask","pixelCellWidth","offscreenCanvas","offscreenCanvasCtx","imageSmoothingEnabled","beginPath","strokeStyle","moveTo","lineTo","stroke","createPersonMask","multiPersonSegmentation","edgeBlurAmount","backgroundMask","drawBokehEffect","backgroundBlurAmount","blurredImage","personMask","createBodyPartMask","bodyPartIdsToMask","blurBodyPart","bodyPartIdsToBlur","bodyPartMask","PART_CHANNELS","version"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\n/**\n * Takes the sigmoid of the part heatmap output and generates a 2d one-hot\n * tensor with ones where the part's score has the maximum value.\n *\n * @param partHeatmapScores\n */\nfunction toFlattenedOneHotPartMap(partHeatmapScores: tf.Tensor3D): tf.Tensor2D {\n  const numParts = partHeatmapScores.shape[2];\n  const partMapLocations = partHeatmapScores.argMax(2);\n\n  const partMapFlattened = partMapLocations.reshape([-1]);\n\n  return tf.oneHot(partMapFlattened, numParts) as tf.Tensor2D;\n}\n\nfunction clipByMask2d(image: tf.Tensor2D, mask: tf.Tensor2D): tf.Tensor2D {\n  return image.mul(mask);\n}\n\n/**\n * Takes the sigmoid of the segmentation output, and generates a segmentation\n * mask with a 1 or 0 at each pixel where there is a person or not a person. The\n * segmentation threshold determines the threshold of a score for a pixel for it\n * to be considered part of a person.\n * @param segmentScores A 3d-tensor of the sigmoid of the segmentation output.\n * @param segmentationThreshold The minimum that segmentation values must have\n * to be considered part of the person.  Affects the generation of the\n * segmentation mask and the clipping of the colored part image.\n *\n * @returns A segmentation mask with a 1 or 0 at each pixel where there is a\n * person or not a person.\n */\nexport function toMaskTensor(\n    segmentScores: tf.Tensor2D, threshold: number): tf.Tensor2D {\n  return tf.tidy(\n      () =>\n          (segmentScores.greater(tf.scalar(threshold)).toInt() as tf.Tensor2D));\n}\n\n/**\n * Takes the sigmoid of the person and part map output, and returns a 2d tensor\n * of an image with the corresponding value at each pixel corresponding to the\n * part with the highest value. These part ids are clipped by the segmentation\n * mask. Wherever the a pixel is clipped by the segmentation mask, its value\n * will set to -1, indicating that there is no part in that pixel.\n * @param segmentScores A 3d-tensor of the sigmoid of the segmentation output.\n * @param partHeatmapScores A 3d-tensor of the sigmoid of the part heatmap\n * output. The third dimension corresponds to the part.\n *\n * @returns A 2d tensor of an image with the corresponding value at each pixel\n * corresponding to the part with the highest value. These part ids are clipped\n * by the segmentation mask.  It will have values of -1 for pixels that are\n * outside of the body and do not have a corresponding part.\n */\nexport function decodePartSegmentation(\n    segmentationMask: tf.Tensor2D,\n    partHeatmapScores: tf.Tensor3D): tf.Tensor2D {\n  const [partMapHeight, partMapWidth, numParts] = partHeatmapScores.shape;\n  return tf.tidy(() => {\n    const flattenedMap = toFlattenedOneHotPartMap(partHeatmapScores);\n    const partNumbers = tf.range(0, numParts, 1, 'int32').expandDims(1);\n\n    const partMapFlattened =\n        flattenedMap.matMul(partNumbers as tf.Tensor2D).toInt();\n\n    const partMap = partMapFlattened.reshape([partMapHeight, partMapWidth]);\n\n    const partMapShiftedUpForClipping = partMap.add(tf.scalar(1, 'int32'));\n\n    return clipByMask2d(\n               partMapShiftedUpForClipping as tf.Tensor2D, segmentationMask)\n        .sub(tf.scalar(1, 'int32'));\n  });\n}\n\nexport function decodeOnlyPartSegmentation(partHeatmapScores: tf.Tensor3D):\n    tf.Tensor2D {\n  const [partMapHeight, partMapWidth, numParts] = partHeatmapScores.shape;\n  return tf.tidy(() => {\n    const flattenedMap = toFlattenedOneHotPartMap(partHeatmapScores);\n    const partNumbers = tf.range(0, numParts, 1, 'int32').expandDims(1);\n\n    const partMapFlattened =\n        flattenedMap.matMul(partNumbers as tf.Tensor2D).toInt();\n\n    return partMapFlattened.reshape([partMapHeight, partMapWidth]);\n  });\n}\n","\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tfconv from '@tensorflow/tfjs-converter';\nimport * as tf from '@tensorflow/tfjs-core';\nimport {BodyPixOutputStride} from './types';\n\n/**\n * BodyPix supports using various convolution neural network models\n * (e.g. ResNet and MobileNetV1) as its underlying base model.\n * The following BaseModel interface defines a unified interface for\n * creating such BodyPix base models. Currently both MobileNet (in\n * ./mobilenet.ts) and ResNet (in ./resnet.ts) implements the BaseModel\n * interface. New base models that conform to the BaseModel interface can be\n * added to BodyPix.\n */\nexport abstract class BaseModel {\n  constructor(\n      protected readonly model: tfconv.GraphModel,\n      public readonly outputStride: BodyPixOutputStride) {\n    const inputShape =\n        this.model.inputs[0].shape as [number, number, number, number];\n    tf.util.assert(\n        (inputShape[1] === -1) && (inputShape[2] === -1),\n        () => `Input shape [${inputShape[1]}, ${inputShape[2]}] ` +\n            `must both be equal to or -1`);\n  }\n\n  abstract preprocessInput(input: tf.Tensor3D): tf.Tensor3D;\n\n  /**\n   * Predicts intermediate Tensor representations.\n   *\n   * @param input The input RGB image of the base model.\n   * A Tensor of shape: [`inputResolution`, `inputResolution`, 3].\n   *\n   * @return A dictionary of base model's intermediate predictions.\n   * The returned dictionary should contains the following elements:\n   * - heatmapScores: A Tensor3D that represents the keypoint heatmap scores.\n   * - offsets: A Tensor3D that represents the offsets.\n   * - displacementFwd: A Tensor3D that represents the forward displacement.\n   * - displacementBwd: A Tensor3D that represents the backward displacement.\n   * - segmentation: A Tensor3D that represents the segmentation of all\n   * people.\n   * - longOffsets: A Tensor3D that represents the long offsets used for\n   * instance grouping.\n   * - partHeatmaps: A Tensor3D that represents the body part segmentation.\n   */\n  predict(input: tf.Tensor3D): {\n    heatmapScores: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D,\n    segmentation: tf.Tensor3D,\n    partHeatmaps: tf.Tensor3D,\n    longOffsets: tf.Tensor3D,\n    partOffsets: tf.Tensor3D\n  } {\n    return tf.tidy(() => {\n      const asFloat = this.preprocessInput(input.toFloat());\n      const asBatch = asFloat.expandDims(0);\n      const results = this.model.predict(asBatch) as tf.Tensor4D[];\n      const results3d: tf.Tensor3D[] = results.map(y => y.squeeze([0]));\n      const namedResults = this.nameOutputResults(results3d);\n\n      return {\n        heatmapScores: namedResults.heatmap.sigmoid(),\n        offsets: namedResults.offsets,\n        displacementFwd: namedResults.displacementFwd,\n        displacementBwd: namedResults.displacementBwd,\n        segmentation: namedResults.segmentation,\n        partHeatmaps: namedResults.partHeatmaps,\n        longOffsets: namedResults.longOffsets,\n        partOffsets: namedResults.partOffsets\n      };\n    });\n  }\n\n  // Because MobileNet and ResNet predict() methods output a different order for\n  // these values, we have a method that needs to be implemented to order them.\n  abstract nameOutputResults(results: tf.Tensor3D[]): {\n    heatmap: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D,\n    segmentation: tf.Tensor3D,\n    partHeatmaps: tf.Tensor3D,\n    longOffsets: tf.Tensor3D,\n    partOffsets: tf.Tensor3D\n  };\n\n  /**\n   * Releases the CPU and GPU memory allocated by the model.\n   */\n  dispose() {\n    this.model.dispose();\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\nimport {BaseModel} from './base_model';\n\nexport class MobileNet extends BaseModel {\n  preprocessInput(input: tf.Tensor3D): tf.Tensor3D {\n    // Normalize the pixels [0, 255] to be between [-1, 1].\n    return tf.tidy(() => tf.div(input, 127.5).sub(1.0));\n  }\n\n  nameOutputResults(results: tf.Tensor3D[]) {\n    const [\n      offsets,\n      segmentation,\n      partHeatmaps,\n      longOffsets,\n      heatmap,\n      displacementFwd,\n      displacementBwd,\n      partOffsets,\n  ] = results;\n    return {\n      offsets,\n      segmentation,\n      partHeatmaps,\n      longOffsets,\n      heatmap,\n      displacementFwd,\n      displacementBwd,\n      partOffsets\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport type Tuple<T> = [T, T];\nexport type StringTuple = Tuple<string>;\nexport type NumberTuple = Tuple<number>;\n\nexport const PART_NAMES = [\n  'nose', 'leftEye', 'rightEye', 'leftEar', 'rightEar', 'leftShoulder',\n  'rightShoulder', 'leftElbow', 'rightElbow', 'leftWrist', 'rightWrist',\n  'leftHip', 'rightHip', 'leftKnee', 'rightKnee', 'leftAnkle', 'rightAnkle'\n];\n\nexport const NUM_KEYPOINTS = PART_NAMES.length;\n\nexport interface NumberDict {\n  [jointName: string]: number;\n}\n\nexport const PART_IDS =\n    PART_NAMES.reduce((result: NumberDict, jointName, i): NumberDict => {\n      result[jointName] = i;\n      return result;\n    }, {}) as NumberDict;\n\nconst CONNECTED_PART_NAMES: StringTuple[] = [\n  ['leftHip', 'leftShoulder'], ['leftElbow', 'leftShoulder'],\n  ['leftElbow', 'leftWrist'], ['leftHip', 'leftKnee'],\n  ['leftKnee', 'leftAnkle'], ['rightHip', 'rightShoulder'],\n  ['rightElbow', 'rightShoulder'], ['rightElbow', 'rightWrist'],\n  ['rightHip', 'rightKnee'], ['rightKnee', 'rightAnkle'],\n  ['leftShoulder', 'rightShoulder'], ['leftHip', 'rightHip']\n];\n\n/*\n * Define the skeleton. This defines the parent->child relationships of our\n * tree. Arbitrarily this defines the nose as the root of the tree, however\n * since we will infer the displacement for both parent->child and\n * child->parent, we can define the tree root as any node.\n */\nexport const POSE_CHAIN: StringTuple[] = [\n  ['nose', 'leftEye'], ['leftEye', 'leftEar'], ['nose', 'rightEye'],\n  ['rightEye', 'rightEar'], ['nose', 'leftShoulder'],\n  ['leftShoulder', 'leftElbow'], ['leftElbow', 'leftWrist'],\n  ['leftShoulder', 'leftHip'], ['leftHip', 'leftKnee'],\n  ['leftKnee', 'leftAnkle'], ['nose', 'rightShoulder'],\n  ['rightShoulder', 'rightElbow'], ['rightElbow', 'rightWrist'],\n  ['rightShoulder', 'rightHip'], ['rightHip', 'rightKnee'],\n  ['rightKnee', 'rightAnkle']\n];\n\nexport const CONNECTED_PART_INDICES = CONNECTED_PART_NAMES.map(\n    ([jointNameA, jointNameB]) =>\n        ([PART_IDS[jointNameA], PART_IDS[jointNameB]]));\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NUM_KEYPOINTS} from '../keypoints';\nimport {Padding, Part, TensorBuffer3D, Vector2D} from '../types';\n\nexport function getScale(\n    [height, width]: [number, number],\n    [inputResolutionY, inputResolutionX]: [number, number],\n    padding: Padding): [number, number] {\n  const {top: padT, bottom: padB, left: padL, right: padR} = padding;\n  const scaleY = inputResolutionY / (padT + padB + height);\n  const scaleX = inputResolutionX / (padL + padR + width);\n  return [scaleX, scaleY];\n}\n\nexport function getOffsetPoint(\n    y: number, x: number, keypoint: number, offsets: TensorBuffer3D): Vector2D {\n  return {\n    y: offsets.get(y, x, keypoint),\n    x: offsets.get(y, x, keypoint + NUM_KEYPOINTS)\n  };\n}\n\nexport function getImageCoords(\n    part: Part, outputStride: number, offsets: TensorBuffer3D): Vector2D {\n  const {heatmapY, heatmapX, id: keypoint} = part;\n  const {y, x} = getOffsetPoint(heatmapY, heatmapX, keypoint, offsets);\n  return {\n    x: part.heatmapX * outputStride + x,\n    y: part.heatmapY * outputStride + y\n  };\n}\n\nexport function fillArray<T>(element: T, size: number): T[] {\n  const result: T[] = new Array(size);\n\n  for (let i = 0; i < size; i++) {\n    result[i] = element;\n  }\n\n  return result;\n}\n\nexport function clamp(a: number, min: number, max: number): number {\n  if (a < min) {\n    return min;\n  }\n  if (a > max) {\n    return max;\n  }\n  return a;\n}\n\nexport function squaredDistance(\n    y1: number, x1: number, y2: number, x2: number): number {\n  const dy = y2 - y1;\n  const dx = x2 - x1;\n  return dy * dy + dx * dx;\n}\n\nexport function addVectors(a: Vector2D, b: Vector2D): Vector2D {\n  return {x: a.x + b.x, y: a.y + b.y};\n}\n\nexport function clampVector(a: Vector2D, min: number, max: number): Vector2D {\n  return {y: clamp(a.y, min, max), x: clamp(a.x, min, max)};\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NUM_KEYPOINTS} from '../keypoints';\nimport {Padding, Pose} from '../types';\n\nimport {getScale} from './util';\n\ninterface Pair {\n  x: number;\n  y: number;\n}\n\nfunction computeDistance(embedding: Pair[], pose: Pose, minPartScore = 0.3) {\n  let distance = 0.0;\n  let numKpt = 0;\n  for (let p = 0; p < embedding.length; p++) {\n    if (pose.keypoints[p].score > minPartScore) {\n      numKpt += 1;\n      distance += (embedding[p].x - pose.keypoints[p].position.x) ** 2 +\n          (embedding[p].y - pose.keypoints[p].position.y) ** 2;\n    }\n  }\n  if (numKpt === 0) {\n    distance = Infinity;\n  } else {\n    distance = distance / numKpt;\n  }\n  return distance;\n}\n\nfunction convertToPositionInOuput(\n    position: Pair, [padT, padL]: [number, number],\n    [scaleX, scaleY]: [number, number], stride: number): Pair {\n  const y = Math.round(((padT + position.y + 1.0) * scaleY - 1.0) / stride);\n  const x = Math.round(((padL + position.x + 1.0) * scaleX - 1.0) / stride);\n  return {x, y};\n}\n\nfunction getEmbedding(\n    location: Pair, keypointIndex: number,\n    convertToPosition: (pair: Pair) => Pair, outputResolutionX: number,\n    longOffsets: Float32Array, refineSteps: number,\n    [height, width]: [number, number]): Pair {\n  const newLocation = convertToPosition(location);\n\n  const nn = newLocation.y * outputResolutionX + newLocation.x;\n  let dy = longOffsets[NUM_KEYPOINTS * (2 * nn) + keypointIndex];\n  let dx = longOffsets[NUM_KEYPOINTS * (2 * nn + 1) + keypointIndex];\n  let y = location.y + dy;\n  let x = location.x + dx;\n  for (let t = 0; t < refineSteps; t++) {\n    y = Math.min(y, height - 1);\n    x = Math.min(x, width - 1);\n    const newPos = convertToPosition({x, y});\n    const nn = newPos.y * outputResolutionX + newPos.x;\n    dy = longOffsets[NUM_KEYPOINTS * (2 * nn) + keypointIndex];\n    dx = longOffsets[NUM_KEYPOINTS * (2 * nn + 1) + keypointIndex];\n    y = y + dy;\n    x = x + dx;\n  }\n\n  return {x, y};\n}\n\nfunction matchEmbeddingToInstance(\n    location: Pair, longOffsets: Float32Array, poses: Pose[],\n    numKptForMatching: number, [padT, padL]: [number, number],\n    [scaleX, scaleY]: [number, number], outputResolutionX: number,\n    [height, width]: [number, number], stride: number,\n    refineSteps: number): number {\n  const embed: Pair[] = [];\n  const convertToPosition = (pair: Pair) =>\n      convertToPositionInOuput(pair, [padT, padL], [scaleX, scaleY], stride);\n\n  for (let keypointsIndex = 0; keypointsIndex < numKptForMatching;\n       keypointsIndex++) {\n    const embedding = getEmbedding(\n        location, keypointsIndex, convertToPosition, outputResolutionX,\n        longOffsets, refineSteps, [height, width]);\n\n    embed.push(embedding);\n  }\n\n  let kMin = -1;\n  let kMinDist = Infinity;\n  for (let k = 0; k < poses.length; k++) {\n    const dist = computeDistance(embed, poses[k]);\n    if (dist < kMinDist) {\n      kMin = k;\n      kMinDist = dist;\n    }\n  }\n  return kMin;\n}\n\nfunction getOutputResolution(\n    [inputResolutionY, inputResolutionX]: [number, number],\n    stride: number): [number, number] {\n  const outputResolutionX = Math.round((inputResolutionX - 1.0) / stride + 1.0);\n  const outputResolutionY = Math.round((inputResolutionY - 1.0) / stride + 1.0);\n  return [outputResolutionX, outputResolutionY];\n}\n\nexport function decodeMultipleMasksCPU(\n    segmentation: Uint8Array, longOffsets: Float32Array,\n    posesAboveScore: Pose[], height: number, width: number, stride: number,\n    [inHeight, inWidth]: [number, number], padding: Padding,\n    refineSteps: number, numKptForMatching = 5): Uint8Array[] {\n  const dataArrays =\n      posesAboveScore.map(x => new Uint8Array(height * width).fill(0));\n\n  const {top: padT, left: padL} = padding;\n\n  const [scaleX, scaleY] =\n      getScale([height, width], [inHeight, inWidth], padding);\n  const [outputResolutionX, ] =\n    getOutputResolution([inHeight, inWidth], stride);\n  for (let i = 0; i < height; i += 1) {\n    for (let j = 0; j < width; j += 1) {\n      const n = i * width + j;\n      const prob = segmentation[n];\n      if (prob === 1) {\n        const kMin = matchEmbeddingToInstance(\n            {x: j, y: i}, longOffsets, posesAboveScore, numKptForMatching,\n            [padT, padL], [scaleX, scaleY], outputResolutionX, [height, width],\n            stride, refineSteps);\n        if (kMin >= 0) {\n          dataArrays[kMin][n] = 1;\n        }\n      }\n    }\n  }\n\n  return dataArrays;\n}\n\nexport function decodeMultiplePartMasksCPU(\n    segmentation: Uint8Array, longOffsets: Float32Array,\n    partSegmentaion: Uint8Array, posesAboveScore: Pose[], height: number,\n    width: number, stride: number, [inHeight, inWidth]: [number, number],\n    padding: Padding, refineSteps: number,\n    numKptForMatching = 5): Int32Array[] {\n  const dataArrays =\n      posesAboveScore.map(x => new Int32Array(height * width).fill(-1));\n\n  const {top: padT, left: padL} = padding;\n\n  const [scaleX, scaleY] =\n      getScale([height, width], [inHeight, inWidth], padding);\n  const [outputResolutionX, ] =\n    getOutputResolution([inHeight, inWidth], stride);\n\n  for (let i = 0; i < height; i += 1) {\n    for (let j = 0; j < width; j += 1) {\n      const n = i * width + j;\n      const prob = segmentation[n];\n      if (prob === 1) {\n        const kMin = matchEmbeddingToInstance(\n            {x: j, y: i}, longOffsets, posesAboveScore, numKptForMatching,\n            [padT, padL], [scaleX, scaleY], outputResolutionX, [height, width],\n            stride, refineSteps);\n        if (kMin >= 0) {\n          dataArrays[kMin][n] = partSegmentaion[n];\n        }\n      }\n    }\n  }\n\n  return dataArrays;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\nimport {NUM_KEYPOINTS} from '../keypoints';\nimport {Padding, Pose} from '../types';\nimport {getScale} from './util';\n\nexport function decodeMultipleMasksWebGl(\n    segmentation: tf.Tensor2D, longOffsets: tf.Tensor3D,\n    posesAboveScore: Pose[], height: number, width: number, stride: number,\n    [inHeight, inWidth]: [number, number], padding: Padding,\n    refineSteps: number, minKptScore: number,\n    maxNumPeople: number): tf.Tensor2D {\n  // The height/width of the image/canvas itself.\n  const [origHeight, origWidth] = segmentation.shape;\n  // The height/width of the output of the model.\n  const [outHeight, outWidth] = longOffsets.shape.slice(0, 2);\n\n  const shapedLongOffsets: tf.Tensor4D =\n      longOffsets.reshape([outHeight, outWidth, 2, NUM_KEYPOINTS]);\n\n  // Make pose tensor of shape [MAX_NUM_PEOPLE, NUM_KEYPOINTS, 3] where\n  // the last 3 coordinates correspond to the score, h and w coordinate of that\n  // keypoint.\n  const poseVals = new Float32Array(maxNumPeople * NUM_KEYPOINTS * 3).fill(0.0);\n  for (let i = 0; i < posesAboveScore.length; i++) {\n    const poseOffset = i * NUM_KEYPOINTS * 3;\n    const pose = posesAboveScore[i];\n    for (let kp = 0; kp < NUM_KEYPOINTS; kp++) {\n      const keypoint = pose.keypoints[kp];\n      const offset = poseOffset + kp * 3;\n      poseVals[offset] = keypoint.score;\n      poseVals[offset + 1] = keypoint.position.y;\n      poseVals[offset + 2] = keypoint.position.x;\n    }\n  }\n\n  const [scaleX, scaleY] =\n      getScale([height, width], [inHeight, inWidth], padding);\n\n  const posesTensor = tf.tensor(poseVals, [maxNumPeople, NUM_KEYPOINTS, 3]);\n\n  const {top: padT, left: padL} = padding;\n\n  const program: tf.webgl.GPGPUProgram = {\n    variableNames: ['segmentation', 'longOffsets', 'poses'],\n    outputShape: [origHeight, origWidth],\n    userCode: `\n    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {\n      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));\n    }\n\n    float convertToPositionInOutputFloat(\n        int pos, int pad, float scale, int stride) {\n      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);\n    }\n\n    float dist(float x1, float y1, float x2, float y2) {\n      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);\n    }\n\n    float sampleLongOffsets(float h, float w, int d, int k) {\n      float fh = fract(h);\n      float fw = fract(w);\n      int clH = int(ceil(h));\n      int clW = int(ceil(w));\n      int flH = int(floor(h));\n      int flW = int(floor(w));\n      float o11 = getLongOffsets(flH, flW, d, k);\n      float o12 = getLongOffsets(flH, clW, d, k);\n      float o21 = getLongOffsets(clH, flW, d, k);\n      float o22 = getLongOffsets(clH, clW, d, k);\n      float o1 = mix(o11, o12, fw);\n      float o2 = mix(o21, o22, fw);\n      return mix(o1, o2, fh);\n    }\n\n    int findNearestPose(int h, int w) {\n      float prob = getSegmentation(h, w);\n      if (prob < 1.0) {\n        return -1;\n      }\n\n      // Done(Tyler): convert from output space h/w to strided space.\n      float stridedH = convertToPositionInOutputFloat(\n        h, ${padT}, ${scaleY}, ${stride});\n      float stridedW = convertToPositionInOutputFloat(\n        w, ${padL}, ${scaleX}, ${stride});\n\n      float minDist = 1000000.0;\n      int iMin = -1;\n      for (int i = 0; i < ${maxNumPeople}; i++) {\n        float curDistSum = 0.0;\n        int numKpt = 0;\n        for (int k = 0; k < ${NUM_KEYPOINTS}; k++) {\n          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);\n          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);\n\n          float y = float(h) + dy;\n          float x = float(w) + dx;\n\n          for (int s = 0; s < ${refineSteps}; s++) {\n            int yRounded = round(min(y, float(${height - 1.0})));\n            int xRounded = round(min(x, float(${width - 1.0})));\n\n            float yStrided = convertToPositionInOutputFloat(\n              yRounded, ${padT}, ${scaleY}, ${stride});\n            float xStrided = convertToPositionInOutputFloat(\n              xRounded, ${padL}, ${scaleX}, ${stride});\n\n            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);\n            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);\n\n            y = y + dy;\n            x = x + dx;\n          }\n\n          float poseScore = getPoses(i, k, 0);\n          float poseY = getPoses(i, k, 1);\n          float poseX = getPoses(i, k, 2);\n          if (poseScore > ${minKptScore}) {\n            numKpt = numKpt + 1;\n            curDistSum = curDistSum + dist(x, y, poseX, poseY);\n          }\n        }\n        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {\n          minDist = curDistSum / float(numKpt);\n          iMin = i;\n        }\n      }\n      return iMin;\n    }\n\n    void main() {\n        ivec2 coords = getOutputCoords();\n        int nearestPose = findNearestPose(coords[0], coords[1]);\n        setOutput(float(nearestPose));\n      }\n  `\n  };\n  const webglBackend = tf.backend() as tf.webgl.MathBackendWebGL;\n  return webglBackend.compileAndRun(\n      program, [segmentation, shapedLongOffsets, posesTensor]);\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\nimport {getBackend} from '@tensorflow/tfjs-core';\n\nimport {Padding, PartSegmentation, PersonSegmentation, Pose} from '../types';\n\nimport {decodeMultipleMasksCPU, decodeMultiplePartMasksCPU} from './decode_multiple_masks_cpu';\nimport {decodeMultipleMasksWebGl} from './decode_multiple_masks_webgl';\n\nexport function toPersonKSegmentation(\n    segmentation: tf.Tensor2D, k: number): tf.Tensor2D {\n  return tf.tidy(\n      () => (segmentation.equal(tf.scalar(k)).toInt() as tf.Tensor2D));\n}\n\nexport function toPersonKPartSegmentation(\n    segmentation: tf.Tensor2D, bodyParts: tf.Tensor2D, k: number): tf.Tensor2D {\n  return tf.tidy(\n      () => segmentation.equal(tf.scalar(k))\n                .toInt()\n                .mul(bodyParts.add(1))\n                .sub(1));\n}\n\nfunction isWebGlBackend() {\n  return getBackend() === 'webgl';\n}\n\nexport async function decodePersonInstanceMasks(\n    segmentation: tf.Tensor2D, longOffsets: tf.Tensor3D, poses: Pose[],\n    height: number, width: number, stride: number,\n    [inHeight, inWidth]: [number, number], padding: Padding, minPoseScore = 0.2,\n    refineSteps = 8, minKeypointScore = 0.3,\n    maxNumPeople = 10): Promise<PersonSegmentation[]> {\n  // Filter out poses with smaller score.\n  const posesAboveScore = poses.filter(pose => pose.score >= minPoseScore);\n\n  let personSegmentationsData: Uint8Array[];\n\n  if (isWebGlBackend()) {\n    const personSegmentations = tf.tidy(() => {\n      const masksTensor = decodeMultipleMasksWebGl(\n          segmentation, longOffsets, posesAboveScore, height, width, stride,\n          [inHeight, inWidth], padding, refineSteps, minKeypointScore,\n          maxNumPeople);\n\n      return posesAboveScore.map(\n          (_, k) => toPersonKSegmentation(masksTensor, k));\n    });\n\n    personSegmentationsData =\n        (await Promise.all(personSegmentations.map(mask => mask.data())) as\n         Uint8Array[]);\n\n    personSegmentations.forEach(x => x.dispose());\n  } else {\n    const segmentationsData = await segmentation.data() as Uint8Array;\n    const longOffsetsData = await longOffsets.data() as Float32Array;\n\n    personSegmentationsData = decodeMultipleMasksCPU(\n        segmentationsData, longOffsetsData, posesAboveScore, height, width,\n        stride, [inHeight, inWidth], padding, refineSteps);\n  }\n\n  return personSegmentationsData.map(\n      (data, i) => ({data, pose: posesAboveScore[i], width, height}));\n}\n\nexport async function decodePersonInstancePartMasks(\n    segmentation: tf.Tensor2D, longOffsets: tf.Tensor3D,\n    partSegmentation: tf.Tensor2D, poses: Pose[], height: number, width: number,\n    stride: number, [inHeight, inWidth]: [number, number], padding: Padding,\n    minPoseScore = 0.2, refineSteps = 8, minKeypointScore = 0.3,\n    maxNumPeople = 10): Promise<PartSegmentation[]> {\n  const posesAboveScore = poses.filter(pose => pose.score >= minPoseScore);\n\n  let partSegmentationsByPersonData: Int32Array[];\n\n  if (isWebGlBackend()) {\n    const partSegmentations = tf.tidy(() => {\n      const masksTensor = decodeMultipleMasksWebGl(\n          segmentation, longOffsets, posesAboveScore, height, width, stride,\n          [inHeight, inWidth], padding, refineSteps, minKeypointScore,\n          maxNumPeople);\n\n      return posesAboveScore.map(\n          (_, k) =>\n              toPersonKPartSegmentation(masksTensor, partSegmentation, k));\n    });\n\n    partSegmentationsByPersonData =\n        (await Promise.all(partSegmentations.map(x => x.data()))) as\n        Int32Array[];\n\n    partSegmentations.forEach(x => x.dispose());\n  } else {\n    const segmentationsData = await segmentation.data() as Uint8Array;\n    const longOffsetsData = await longOffsets.data() as Float32Array;\n    const partSegmentaionData = await partSegmentation.data() as Uint8Array;\n\n    partSegmentationsByPersonData = decodeMultiplePartMasksCPU(\n        segmentationsData, longOffsetsData, partSegmentaionData,\n        posesAboveScore, height, width, stride, [inHeight, inWidth], padding,\n        refineSteps);\n  }\n\n  return partSegmentationsByPersonData.map(\n      (data, k) => ({pose: posesAboveScore[k], data, height, width}));\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// algorithm based on Coursera Lecture from Algorithms, Part 1:\n// https://www.coursera.org/learn/algorithms-part1/lecture/ZjoSM/heapsort\n\nfunction half(k: number) {\n  return Math.floor(k / 2);\n}\n\nexport class MaxHeap<T> {\n  private priorityQueue: T[];\n  private numberOfElements: number;\n  private getElementValue: (element: T) => number;\n\n  constructor(maxSize: number, getElementValue: (element: T) => number) {\n    this.priorityQueue = new Array(maxSize);\n    this.numberOfElements = -1;\n    this.getElementValue = getElementValue;\n  }\n\n  public enqueue(x: T): void {\n    this.priorityQueue[++this.numberOfElements] = x;\n    this.swim(this.numberOfElements);\n  }\n\n  public dequeue(): T {\n    const max = this.priorityQueue[0];\n    this.exchange(0, this.numberOfElements--);\n    this.sink(0);\n    this.priorityQueue[this.numberOfElements + 1] = null;\n    return max;\n  }\n\n  public empty(): boolean {\n    return this.numberOfElements === -1;\n  }\n\n  public size(): number {\n    return this.numberOfElements + 1;\n  }\n\n  public all(): T[] {\n    return this.priorityQueue.slice(0, this.numberOfElements + 1);\n  }\n\n  public max(): T {\n    return this.priorityQueue[0];\n  }\n\n  private swim(k: number): void {\n    while (k > 0 && this.less(half(k), k)) {\n      this.exchange(k, half(k));\n      k = half(k);\n    }\n  }\n\n  private sink(k: number): void {\n    while (2 * k <= this.numberOfElements) {\n      let j = 2 * k;\n      if (j < this.numberOfElements && this.less(j, j + 1)) {\n        j++;\n      }\n      if (!this.less(k, j)) {\n        break;\n      }\n      this.exchange(k, j);\n      k = j;\n    }\n  }\n\n  private getValueAt(i: number): number {\n    return this.getElementValue(this.priorityQueue[i]);\n  }\n\n  private less(i: number, j: number): boolean {\n    return this.getValueAt(i) < this.getValueAt(j);\n  }\n\n  private exchange(i: number, j: number): void {\n    const t = this.priorityQueue[i];\n    this.priorityQueue[i] = this.priorityQueue[j];\n    this.priorityQueue[j] = t;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {PartWithScore, TensorBuffer3D} from '../types';\n\nimport {MaxHeap} from './max_heap';\n\nfunction scoreIsMaximumInLocalWindow(\n    keypointId: number, score: number, heatmapY: number, heatmapX: number,\n    localMaximumRadius: number, scores: TensorBuffer3D): boolean {\n  const [height, width] = scores.shape;\n\n  let localMaximum = true;\n  const yStart = Math.max(heatmapY - localMaximumRadius, 0);\n  const yEnd = Math.min(heatmapY + localMaximumRadius + 1, height);\n  for (let yCurrent = yStart; yCurrent < yEnd; ++yCurrent) {\n    const xStart = Math.max(heatmapX - localMaximumRadius, 0);\n    const xEnd = Math.min(heatmapX + localMaximumRadius + 1, width);\n    for (let xCurrent = xStart; xCurrent < xEnd; ++xCurrent) {\n      if (scores.get(yCurrent, xCurrent, keypointId) > score) {\n        localMaximum = false;\n        break;\n      }\n    }\n    if (!localMaximum) {\n      break;\n    }\n  }\n\n  return localMaximum;\n}\n\n/**\n * Builds a priority queue with part candidate positions for a specific image in\n * the batch. For this we find all local maxima in the score maps with score\n * values above a threshold. We create a single priority queue across all parts.\n */\nexport function buildPartWithScoreQueue(\n    scoreThreshold: number, localMaximumRadius: number,\n    scores: TensorBuffer3D): MaxHeap<PartWithScore> {\n  const [height, width, numKeypoints] = scores.shape;\n\n  const queue = new MaxHeap<PartWithScore>(\n      height * width * numKeypoints, ({score}) => score);\n\n  for (let heatmapY = 0; heatmapY < height; ++heatmapY) {\n    for (let heatmapX = 0; heatmapX < width; ++heatmapX) {\n      for (let keypointId = 0; keypointId < numKeypoints; ++keypointId) {\n        const score = scores.get(heatmapY, heatmapX, keypointId);\n\n        // Only consider parts with score greater or equal to threshold as\n        // root candidates.\n        if (score < scoreThreshold) {\n          continue;\n        }\n\n        // Only consider keypoints whose score is maximum in a local window.\n        if (scoreIsMaximumInLocalWindow(\n                keypointId, score, heatmapY, heatmapX, localMaximumRadius,\n                scores)) {\n          queue.enqueue({score, part: {heatmapY, heatmapX, id: keypointId}});\n        }\n      }\n    }\n  }\n\n  return queue;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NumberTuple, PART_IDS, PART_NAMES, POSE_CHAIN} from '../keypoints';\nimport {Keypoint, PartWithScore, TensorBuffer3D, Vector2D} from '../types';\n\nimport {clamp, getOffsetPoint} from './util';\nimport {addVectors, getImageCoords} from './util';\n\nconst parentChildrenTuples: NumberTuple[] = POSE_CHAIN.map(\n    ([parentJoinName, childJoinName]): NumberTuple =>\n        ([PART_IDS[parentJoinName], PART_IDS[childJoinName]]));\n\nconst parentToChildEdges: number[] =\n    parentChildrenTuples.map(([, childJointId]) => childJointId);\n\nconst childToParentEdges: number[] =\n    parentChildrenTuples.map(([\n                               parentJointId,\n                             ]) => parentJointId);\n\nfunction getDisplacement(\n    edgeId: number, point: Vector2D, displacements: TensorBuffer3D): Vector2D {\n  const numEdges = displacements.shape[2] / 2;\n  return {\n    y: displacements.get(point.y, point.x, edgeId),\n    x: displacements.get(point.y, point.x, numEdges + edgeId)\n  };\n}\n\nfunction getStridedIndexNearPoint(\n    point: Vector2D, outputStride: number, height: number,\n    width: number): Vector2D {\n  return {\n    y: clamp(Math.round(point.y / outputStride), 0, height - 1),\n    x: clamp(Math.round(point.x / outputStride), 0, width - 1)\n  };\n}\n\n/**\n * We get a new keypoint along the `edgeId` for the pose instance, assuming\n * that the position of the `idSource` part is already known. For this, we\n * follow the displacement vector from the source to target part (stored in\n * the `i`-t channel of the displacement tensor). The displaced keypoint\n * vector is refined using the offset vector by `offsetRefineStep` times.\n */\nfunction traverseToTargetKeypoint(\n    edgeId: number, sourceKeypoint: Keypoint, targetKeypointId: number,\n    scoresBuffer: TensorBuffer3D, offsets: TensorBuffer3D, outputStride: number,\n    displacements: TensorBuffer3D, offsetRefineStep = 2): Keypoint {\n  const [height, width] = scoresBuffer.shape;\n\n  // Nearest neighbor interpolation for the source->target displacements.\n  const sourceKeypointIndices = getStridedIndexNearPoint(\n      sourceKeypoint.position, outputStride, height, width);\n\n  const displacement =\n      getDisplacement(edgeId, sourceKeypointIndices, displacements);\n\n  const displacedPoint = addVectors(sourceKeypoint.position, displacement);\n  let targetKeypoint = displacedPoint;\n  for (let i = 0; i < offsetRefineStep; i++) {\n    const targetKeypointIndices =\n        getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);\n\n    const offsetPoint = getOffsetPoint(\n        targetKeypointIndices.y, targetKeypointIndices.x, targetKeypointId,\n        offsets);\n\n    targetKeypoint = addVectors(\n        {\n          x: targetKeypointIndices.x * outputStride,\n          y: targetKeypointIndices.y * outputStride\n        },\n        {x: offsetPoint.x, y: offsetPoint.y});\n  }\n  const targetKeyPointIndices =\n      getStridedIndexNearPoint(targetKeypoint, outputStride, height, width);\n  const score = scoresBuffer.get(\n      targetKeyPointIndices.y, targetKeyPointIndices.x, targetKeypointId);\n\n  return {position: targetKeypoint, part: PART_NAMES[targetKeypointId], score};\n}\n\n/**\n * Follows the displacement fields to decode the full pose of the object\n * instance given the position of a part that acts as root.\n *\n * @return An array of decoded keypoints and their scores for a single pose\n */\nexport function decodePose(\n    root: PartWithScore, scores: TensorBuffer3D, offsets: TensorBuffer3D,\n    outputStride: number, displacementsFwd: TensorBuffer3D,\n    displacementsBwd: TensorBuffer3D): Keypoint[] {\n  const numParts = scores.shape[2];\n  const numEdges = parentToChildEdges.length;\n\n  const instanceKeypoints: Keypoint[] = new Array(numParts);\n  // Start a new detection instance at the position of the root.\n  const {part: rootPart, score: rootScore} = root;\n  const rootPoint = getImageCoords(rootPart, outputStride, offsets);\n\n  instanceKeypoints[rootPart.id] = {\n    score: rootScore,\n    part: PART_NAMES[rootPart.id],\n    position: rootPoint\n  };\n\n  // Decode the part positions upwards in the tree, following the backward\n  // displacements.\n  for (let edge = numEdges - 1; edge >= 0; --edge) {\n    const sourceKeypointId = parentToChildEdges[edge];\n    const targetKeypointId = childToParentEdges[edge];\n    if (instanceKeypoints[sourceKeypointId] &&\n        !instanceKeypoints[targetKeypointId]) {\n      instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(\n          edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores,\n          offsets, outputStride, displacementsBwd);\n    }\n  }\n\n  // Decode the part positions downwards in the tree, following the forward\n  // displacements.\n  for (let edge = 0; edge < numEdges; ++edge) {\n    const sourceKeypointId = childToParentEdges[edge];\n    const targetKeypointId = parentToChildEdges[edge];\n    if (instanceKeypoints[sourceKeypointId] &&\n        !instanceKeypoints[targetKeypointId]) {\n      instanceKeypoints[targetKeypointId] = traverseToTargetKeypoint(\n          edge, instanceKeypoints[sourceKeypointId], targetKeypointId, scores,\n          offsets, outputStride, displacementsFwd);\n    }\n  }\n\n  return instanceKeypoints;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Keypoint, Pose, TensorBuffer3D} from '../types';\n\nimport {buildPartWithScoreQueue} from './build_part_with_score_queue';\nimport {decodePose} from './decode_pose';\nimport {getImageCoords, squaredDistance} from './util';\n\nfunction withinNmsRadiusOfCorrespondingPoint(\n    poses: Pose[], squaredNmsRadius: number, {x, y}: {x: number, y: number},\n    keypointId: number): boolean {\n  return poses.some(({keypoints}) => {\n    const correspondingKeypoint = keypoints[keypointId].position;\n    return squaredDistance(\n               y, x, correspondingKeypoint.y, correspondingKeypoint.x) <=\n        squaredNmsRadius;\n  });\n}\n\n/* Score the newly proposed object instance without taking into account\n * the scores of the parts that overlap with any previously detected\n * instance.\n */\nfunction getInstanceScore(\n    existingPoses: Pose[], squaredNmsRadius: number,\n    instanceKeypoints: Keypoint[]): number {\n  let notOverlappedKeypointScores = instanceKeypoints.reduce(\n      (result, {position, score}, keypointId): number => {\n        if (!withinNmsRadiusOfCorrespondingPoint(\n                existingPoses, squaredNmsRadius, position, keypointId)) {\n          result += score;\n        }\n        return result;\n      }, 0.0);\n\n  return notOverlappedKeypointScores /= instanceKeypoints.length;\n}\n\n// A point (y, x) is considered as root part candidate if its score is a\n// maximum in a window |y - y'| <= kLocalMaximumRadius, |x - x'| <=\n// kLocalMaximumRadius.\nconst kLocalMaximumRadius = 1;\n\n/**\n * Detects multiple poses and finds their parts from part scores and\n * displacement vectors. It returns up to `maxDetections` object instance\n * detections in decreasing root score order. It works as follows: We first\n * create a priority queue with local part score maxima above\n * `scoreThreshold`, considering all parts at the same time. Then we\n * iteratively pull the top  element of the queue (in decreasing score order)\n * and treat it as a root candidate for a new object instance. To avoid\n * duplicate detections, we reject the root candidate if it is within a disk\n * of `nmsRadius` pixels from the corresponding part of a previously detected\n * instance, which is a form of part-based non-maximum suppression (NMS). If\n * the root candidate passes the NMS check, we start a new object instance\n * detection, treating the corresponding part as root and finding the\n * positions of the remaining parts by following the displacement vectors\n * along the tree-structured part graph. We assign to the newly detected\n * instance a score equal to the sum of scores of its parts which have not\n * been claimed by a previous instance (i.e., those at least `nmsRadius`\n * pixels away from the corresponding part of all previously detected\n * instances), divided by the total number of parts `numParts`.\n *\n * @param heatmapScores 3-D tensor with shape `[height, width, numParts]`.\n * The value of heatmapScores[y, x, k]` is the score of placing the `k`-th\n * object part at position `(y, x)`.\n *\n * @param offsets 3-D tensor with shape `[height, width, numParts * 2]`.\n * The value of [offsets[y, x, k], offsets[y, x, k + numParts]]` is the\n * short range offset vector of the `k`-th  object part at heatmap\n * position `(y, x)`.\n *\n * @param displacementsFwd 3-D tensor of shape\n * `[height, width, 2 * num_edges]`, where `num_edges = num_parts - 1` is the\n * number of edges (parent-child pairs) in the tree. It contains the forward\n * displacements between consecutive part from the root towards the leaves.\n *\n * @param displacementsBwd 3-D tensor of shape\n * `[height, width, 2 * num_edges]`, where `num_edges = num_parts - 1` is the\n * number of edges (parent-child pairs) in the tree. It contains the backward\n * displacements between consecutive part from the root towards the leaves.\n *\n * @param outputStride The output stride that was used when feed-forwarding\n * through the PoseNet model.  Must be 32, 16, or 8.\n *\n * @param maxPoseDetections Maximum number of returned instance detections per\n * image.\n *\n * @param scoreThreshold Only return instance detections that have root part\n * score greater or equal to this value. Defaults to 0.5.\n *\n * @param nmsRadius Non-maximum suppression part distance. It needs to be\n * strictly positive. Two parts suppress each other if they are less than\n * `nmsRadius` pixels away. Defaults to 20.\n *\n * @return An array of poses and their scores, each containing keypoints and\n * the corresponding keypoint scores.\n */\nexport function decodeMultiplePoses(\n    scoresBuffer: TensorBuffer3D, offsetsBuffer: TensorBuffer3D,\n    displacementsFwdBuffer: TensorBuffer3D,\n    displacementsBwdBuffer: TensorBuffer3D, outputStride: number,\n    maxPoseDetections: number, scoreThreshold = 0.5, nmsRadius = 20): Pose[] {\n  const poses: Pose[] = [];\n\n  const queue = buildPartWithScoreQueue(\n      scoreThreshold, kLocalMaximumRadius, scoresBuffer);\n\n  const squaredNmsRadius = nmsRadius * nmsRadius;\n\n  // Generate at most maxDetections object instances per image in\n  // decreasing root part score order.\n  while (poses.length < maxPoseDetections && !queue.empty()) {\n    // The top element in the queue is the next root candidate.\n    const root = queue.dequeue();\n\n    // Part-based non-maximum suppression: We reject a root candidate if it\n    // is within a disk of `nmsRadius` pixels from the corresponding part of\n    // a previously detected instance.\n    const rootImageCoords =\n        getImageCoords(root.part, outputStride, offsetsBuffer);\n    if (withinNmsRadiusOfCorrespondingPoint(\n            poses, squaredNmsRadius, rootImageCoords, root.part.id)) {\n      continue;\n    }\n\n    // Start a new detection instance at the position of the root.\n    const keypoints = decodePose(\n        root, scoresBuffer, offsetsBuffer, outputStride, displacementsFwdBuffer,\n        displacementsBwdBuffer);\n\n    const score = getInstanceScore(poses, squaredNmsRadius, keypoints);\n\n    poses.push({keypoints, score});\n  }\n\n  return poses;\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs-core';\n\nimport {BaseModel} from './base_model';\n\nconst imageNetMean = [-123.15, -115.90, -103.06];\n\nexport class ResNet extends BaseModel {\n  preprocessInput(input: tf.Tensor3D): tf.Tensor3D {\n    return input.add(imageNetMean);\n  }\n\n  nameOutputResults(results: tf.Tensor3D[]) {\n    const [\n      displacementBwd,\n      displacementFwd,\n      heatmap,\n      longOffsets,\n      offsets,\n      partHeatmaps,\n      segmentation,\n      partOffsets,\n  ] = results;\n    return {\n      offsets,\n      segmentation,\n      partHeatmaps,\n      longOffsets,\n      heatmap,\n      displacementFwd,\n      displacementBwd,\n      partOffsets\n    };\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nconst RESNET50_BASE_URL =\n    'https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/';\nconst MOBILENET_BASE_URL =\n    'https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/';\n\n// The BodyPix 2.0 ResNet50 models use the latest TensorFlow.js 1.0 model\n// format.\nexport function resNet50SavedModel(stride: number, quantBytes: number): string {\n  const graphJson = `model-stride${stride}.json`;\n  // quantBytes=4 corresponding to the non-quantized full-precision SavedModel.\n  if (quantBytes === 4) {\n    return RESNET50_BASE_URL + `float/` + graphJson;\n  } else {\n    return RESNET50_BASE_URL + `quant${quantBytes}/` + graphJson;\n  }\n}\n\n// The BodyPix 2.0 MobileNetV1 models use the latest TensorFlow.js 1.0 model\n// format.\nexport function mobileNetSavedModel(\n    stride: number, multiplier: number, quantBytes: number): string {\n  const toStr: {[key: number]: string} = {1.0: '100', 0.75: '075', 0.50: '050'};\n  const graphJson = `model-stride${stride}.json`;\n  // quantBytes=4 corresponding to the non-quantized full-precision SavedModel.\n  if (quantBytes === 4) {\n    return MOBILENET_BASE_URL + `float/${toStr[multiplier]}/` + graphJson;\n  } else {\n    return MOBILENET_BASE_URL + `quant${quantBytes}/${toStr[multiplier]}/` +\n        graphJson;\n  }\n}\n","import * as tf from '@tensorflow/tfjs-core';\n\nimport {BodyPixInput, BodyPixOutputStride, Padding} from './types';\nimport {Pose, TensorBuffer3D} from './types';\nimport {BodyPixInternalResolution} from './types';\n\nfunction getSizeFromImageLikeElement(input: HTMLImageElement|\n                                     HTMLCanvasElement): [number, number] {\n  if (input.offsetHeight !== 0 && input.offsetWidth !== 0) {\n    return [input.offsetHeight, input.offsetWidth];\n  } else if (input.height != null && input.width != null) {\n    return [input.height, input.width];\n  } else {\n    throw new Error(\n        `HTMLImageElement must have height and width attributes set.`);\n  }\n}\n\nfunction getSizeFromVideoElement(input: HTMLVideoElement): [number, number] {\n  if (input.height != null && input.width != null) {\n    // Prioritizes user specified height and width.\n    return [input.height, input.width];\n  } else {\n    return [input.videoHeight, input.videoWidth];\n  }\n}\n\nexport function getInputSize(input: BodyPixInput): [number, number] {\n  if ((typeof (HTMLCanvasElement) !== 'undefined' &&\n       input instanceof HTMLCanvasElement) ||\n      (typeof (HTMLImageElement) !== 'undefined' &&\n       input instanceof HTMLImageElement)) {\n    return getSizeFromImageLikeElement(input);\n  } else if (typeof (ImageData) !== 'undefined' && input instanceof ImageData) {\n    return [input.height, input.width];\n  } else if (\n      typeof (HTMLVideoElement) !== 'undefined' &&\n      input instanceof HTMLVideoElement) {\n    return getSizeFromVideoElement(input);\n  } else if (input instanceof tf.Tensor) {\n    return [input.shape[0], input.shape[1]];\n  } else {\n    throw new Error(`error: Unknown input type: ${input}.`);\n  }\n}\n\nfunction isValidInputResolution(\n    resolution: number, outputStride: number): boolean {\n  return (resolution - 1) % outputStride === 0;\n}\n\nexport function toValidInputResolution(\n    inputResolution: number, outputStride: BodyPixOutputStride): number {\n  if (isValidInputResolution(inputResolution, outputStride)) {\n    return inputResolution;\n  }\n\n  return Math.floor(inputResolution / outputStride) * outputStride + 1;\n}\n\nconst INTERNAL_RESOLUTION_STRING_OPTIONS = {\n  low: 'low',\n  medium: 'medium',\n  high: 'high',\n  full: 'full'\n};\n\nconst INTERNAL_RESOLUTION_PERCENTAGES = {\n  [INTERNAL_RESOLUTION_STRING_OPTIONS.low]: 0.25,\n  [INTERNAL_RESOLUTION_STRING_OPTIONS.medium]: 0.5,\n  [INTERNAL_RESOLUTION_STRING_OPTIONS.high]: 0.75,\n  [INTERNAL_RESOLUTION_STRING_OPTIONS.full]: 1.0\n};\n\nconst MIN_INTERNAL_RESOLUTION = 0.1;\nconst MAX_INTERNAL_RESOLUTION = 2.0;\n\nfunction toInternalResolutionPercentage(\n    internalResolution: BodyPixInternalResolution): number {\n  if (typeof internalResolution === 'string') {\n    const result = INTERNAL_RESOLUTION_PERCENTAGES[internalResolution];\n\n    tf.util.assert(\n        typeof result === 'number',\n        () => `string value of inputResolution must be one of ${\n            Object.values(INTERNAL_RESOLUTION_STRING_OPTIONS)\n                .join(',')} but was ${internalResolution}.`);\n    return result;\n  } else {\n    tf.util.assert(\n        typeof internalResolution === 'number' &&\n            internalResolution <= MAX_INTERNAL_RESOLUTION &&\n            internalResolution >= MIN_INTERNAL_RESOLUTION,\n        () =>\n            `inputResolution must be a string or number between ${\n                MIN_INTERNAL_RESOLUTION} and ${MAX_INTERNAL_RESOLUTION}, but ` +\n            `was ${internalResolution}`);\n\n    return internalResolution;\n  }\n}\n\nexport function toInputResolutionHeightAndWidth(\n    internalResolution: BodyPixInternalResolution,\n    outputStride: BodyPixOutputStride,\n    [inputHeight, inputWidth]: [number, number]): [number, number] {\n  const internalResolutionPercentage =\n      toInternalResolutionPercentage(internalResolution);\n\n  return [\n    toValidInputResolution(\n        inputHeight * internalResolutionPercentage, outputStride),\n    toValidInputResolution(\n        inputWidth * internalResolutionPercentage, outputStride)\n  ];\n}\n\nexport function toInputTensor(input: BodyPixInput) {\n  return input instanceof tf.Tensor ? input : tf.browser.fromPixels(input);\n}\n\nexport function resizeAndPadTo(\n    imageTensor: tf.Tensor3D, [targetH, targetW]: [number, number],\n    flipHorizontal = false): {\n  resizedAndPadded: tf.Tensor3D,\n  paddedBy: [[number, number], [number, number]]\n} {\n  const [height, width] = imageTensor.shape;\n\n  const targetAspect = targetW / targetH;\n  const aspect = width / height;\n\n  let resizeW: number;\n  let resizeH: number;\n  let padL: number;\n  let padR: number;\n  let padT: number;\n  let padB: number;\n\n  if (aspect > targetAspect) {\n    // resize to have the larger dimension match the shape.\n    resizeW = targetW;\n    resizeH = Math.ceil(resizeW / aspect);\n\n    const padHeight = targetH - resizeH;\n    padL = 0;\n    padR = 0;\n    padT = Math.floor(padHeight / 2);\n    padB = targetH - (resizeH + padT);\n  } else {\n    resizeH = targetH;\n    resizeW = Math.ceil(targetH * aspect);\n\n    const padWidth = targetW - resizeW;\n    padL = Math.floor(padWidth / 2);\n    padR = targetW - (resizeW + padL);\n    padT = 0;\n    padB = 0;\n  }\n\n  const resizedAndPadded = tf.tidy(() => {\n    // resize to have largest dimension match image\n    let resized: tf.Tensor3D;\n    if (flipHorizontal) {\n      resized = imageTensor.reverse(1).resizeBilinear([resizeH, resizeW]);\n    } else {\n      resized = imageTensor.resizeBilinear([resizeH, resizeW]);\n    }\n\n    const padded = tf.pad3d(resized, [[padT, padB], [padL, padR], [0, 0]]);\n\n    return padded;\n  });\n\n  return {resizedAndPadded, paddedBy: [[padT, padB], [padL, padR]]};\n}\n\nexport function scaleAndCropToInputTensorShape(\n    tensor: tf.Tensor3D,\n    [inputTensorHeight, inputTensorWidth]: [number, number],\n    [resizedAndPaddedHeight, resizedAndPaddedWidth]: [number, number],\n    [[padT, padB], [padL, padR]]: [[number, number], [number, number]],\n    applySigmoidActivation = false): tf.Tensor3D {\n  return tf.tidy(() => {\n    let inResizedAndPadded = tensor.resizeBilinear(\n        [resizedAndPaddedHeight, resizedAndPaddedWidth], true);\n\n    if (applySigmoidActivation) {\n      inResizedAndPadded = inResizedAndPadded.sigmoid();\n    }\n\n    return removePaddingAndResizeBack(\n        inResizedAndPadded, [inputTensorHeight, inputTensorWidth],\n        [[padT, padB], [padL, padR]]);\n  });\n}\n\nexport function removePaddingAndResizeBack(\n    resizedAndPadded: tf.Tensor3D,\n    [originalHeight, originalWidth]: [number, number],\n    [[padT, padB], [padL, padR]]: [[number, number], [number, number]]):\n    tf.Tensor3D {\n  return tf.tidy(() => {\n    return tf.image\n        .cropAndResize(\n            resizedAndPadded.expandDims(), [[\n              padT / (originalHeight + padT + padB - 1.0),\n              padL / (originalWidth + padL + padR - 1.0),\n              (padT + originalHeight - 1.0) /\n                  (originalHeight + padT + padB - 1.0),\n              (padL + originalWidth - 1.0) / (originalWidth + padL + padR - 1.0)\n            ]],\n            [0], [originalHeight, originalWidth])\n        .squeeze([0]);\n  });\n}\n\nexport function resize2d(\n    tensor: tf.Tensor2D, resolution: [number, number],\n    nearestNeighbor?: boolean): tf.Tensor2D {\n  return tf.tidy(() => {\n    return tensor.expandDims<tf.Rank.R3>(2)\n        .resizeBilinear(resolution, nearestNeighbor)\n        .squeeze();\n  });\n}\n\nexport function padAndResizeTo(\n    input: BodyPixInput, [targetH, targetW]: [number, number]):\n    {resized: tf.Tensor3D, padding: Padding} {\n  const [height, width] = getInputSize(input);\n  const targetAspect = targetW / targetH;\n  const aspect = width / height;\n  let [padT, padB, padL, padR] = [0, 0, 0, 0];\n  if (aspect < targetAspect) {\n    // pads the width\n    padT = 0;\n    padB = 0;\n    padL = Math.round(0.5 * (targetAspect * height - width));\n    padR = Math.round(0.5 * (targetAspect * height - width));\n  } else {\n    // pads the height\n    padT = Math.round(0.5 * ((1.0 / targetAspect) * width - height));\n    padB = Math.round(0.5 * ((1.0 / targetAspect) * width - height));\n    padL = 0;\n    padR = 0;\n  }\n\n  const resized: tf.Tensor3D = tf.tidy(() => {\n    let imageTensor = toInputTensor(input);\n    imageTensor = tf.pad3d(imageTensor, [[padT, padB], [padL, padR], [0, 0]]);\n\n    return imageTensor.resizeBilinear([targetH, targetW]);\n  });\n\n  return {resized, padding: {top: padT, left: padL, right: padR, bottom: padB}};\n}\n\nexport async function toTensorBuffers3D(tensors: tf.Tensor3D[]):\n    Promise<TensorBuffer3D[]> {\n  return Promise.all(tensors.map(tensor => tensor.buffer()));\n}\n\nexport function scalePose(\n    pose: Pose, scaleY: number, scaleX: number, offsetY = 0,\n    offsetX = 0): Pose {\n  return {\n    score: pose.score,\n    keypoints: pose.keypoints.map(({score, part, position}) => ({\n                                    score,\n                                    part,\n                                    position: {\n                                      x: position.x * scaleX + offsetX,\n                                      y: position.y * scaleY + offsetY\n                                    }\n                                  }))\n  };\n}\n\nexport function scalePoses(\n    poses: Pose[], scaleY: number, scaleX: number, offsetY = 0, offsetX = 0) {\n  if (scaleX === 1 && scaleY === 1 && offsetY === 0 && offsetX === 0) {\n    return poses;\n  }\n  return poses.map(pose => scalePose(pose, scaleY, scaleX, offsetY, offsetX));\n}\n\nexport function flipPoseHorizontal(pose: Pose, imageWidth: number): Pose {\n  return {\n    score: pose.score,\n    keypoints: pose.keypoints.map(\n        ({score, part, position}) => ({\n          score,\n          part,\n          position: {x: imageWidth - 1 - position.x, y: position.y}\n        }))\n  };\n}\n\nexport function flipPosesHorizontal(poses: Pose[], imageWidth: number) {\n  if (imageWidth <= 0) {\n    return poses;\n  }\n  return poses.map(pose => flipPoseHorizontal(pose, imageWidth));\n}\n\nexport function scaleAndFlipPoses(\n    poses: Pose[], [height, width]: [number, number],\n    [inputResolutionHeight, inputResolutionWidth]: [number, number],\n    padding: Padding, flipHorizontal: boolean): Pose[] {\n  const scaleY =\n      (height + padding.top + padding.bottom) / (inputResolutionHeight);\n  const scaleX =\n      (width + padding.left + padding.right) / (inputResolutionWidth);\n\n  const scaledPoses =\n      scalePoses(poses, scaleY, scaleX, -padding.top, -padding.left);\n\n  if (flipHorizontal) {\n    return flipPosesHorizontal(scaledPoses, width);\n  } else {\n    return scaledPoses;\n  }\n}\n","\n/**\n * @license\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tfconv from '@tensorflow/tfjs-converter';\nimport * as tf from '@tensorflow/tfjs-core';\n\nimport {BaseModel} from './base_model';\nimport {decodeOnlyPartSegmentation, decodePartSegmentation, toMaskTensor} from './decode_part_map';\nimport {MobileNet} from './mobilenet';\nimport {decodePersonInstanceMasks, decodePersonInstancePartMasks} from './multi_person/decode_instance_masks';\nimport {decodeMultiplePoses} from './multi_person/decode_multiple_poses';\nimport {ResNet} from './resnet';\nimport {mobileNetSavedModel, resNet50SavedModel} from './saved_models';\nimport {BodyPixArchitecture, BodyPixInput, BodyPixInternalResolution, BodyPixMultiplier, BodyPixOutputStride, BodyPixQuantBytes, Padding} from './types';\nimport {PartSegmentation, PersonSegmentation, SemanticPartSegmentation, SemanticPersonSegmentation} from './types';\nimport {getInputSize, padAndResizeTo, scaleAndCropToInputTensorShape, scaleAndFlipPoses, toInputResolutionHeightAndWidth, toTensorBuffers3D} from './util';\n\nconst APPLY_SIGMOID_ACTIVATION = true;\nconst FLIP_POSES_AFTER_SCALING = false;\n\n/**\n * BodyPix model loading is configurable using the following config dictionary.\n *\n * `architecture`: BodyPixArchitecture. It determines which BodyPix architecture\n * to load. The supported architectures are: MobileNetV1 and ResNet50.\n *\n * `outputStride`: Specifies the output stride of the BodyPix model.\n * The smaller the value, the larger the output resolution, and more accurate\n * the model at the cost of speed. Set this to a larger value to increase speed\n * at the cost of accuracy. Stride 32 is supported for ResNet and\n * stride 8,16,32 are supported for various MobileNetV1 models.\n *\n * `multiplier`: An optional number with values: 1.01, 1.0, 0.75, or\n * 0.50. The value is used only by MobileNet architecture. It is the float\n * multiplier for the depth (number of channels) for all convolution ops.\n * The larger the value, the larger the size of the layers, and more accurate\n * the model at the cost of speed. Set this to a smaller value to increase speed\n * at the cost of accuracy.\n *\n * `modelUrl`: An optional string that specifies custom url of the model. This\n * is useful for area/countries that don't have access to the model hosted on\n * GCP.\n *\n * `quantBytes`: An optional number with values: 1, 2, or 4.  This parameter\n * affects weight quantization in the models. The available options are\n * 1 byte, 2 bytes, and 4 bytes. The higher the value, the larger the model size\n * and thus the longer the loading time, the lower the value, the shorter the\n * loading time but lower the accuracy.\n */\nexport interface ModelConfig {\n  architecture: BodyPixArchitecture;\n  outputStride: BodyPixOutputStride;\n  multiplier?: BodyPixMultiplier;\n  modelUrl?: string;\n  quantBytes?: BodyPixQuantBytes;\n}\n\n// The default configuration for loading MobileNetV1 based BodyPix.\n//\n// (And for references, the default configuration for loading ResNet\n// based PoseNet is also included).\n//\n// ```\n// const RESNET_CONFIG = {\n//   architecture: 'ResNet50',\n//   outputStride: 32,\n//   quantBytes: 4,\n// } as ModelConfig;\n// ```\n\nconst MOBILENET_V1_CONFIG = {\n  architecture: 'MobileNetV1',\n  outputStride: 16,\n  quantBytes: 4,\n  multiplier: 0.75,\n} as ModelConfig;\n\nconst VALID_ARCHITECTURE: BodyPixArchitecture[] = ['MobileNetV1', 'ResNet50'];\nconst VALID_STRIDE: {[id: string]: BodyPixOutputStride[]} = {\n  'MobileNetV1': [8, 16, 32],\n  'ResNet50': [32, 16]\n};\nconst VALID_MULTIPLIER: {[id: string]: BodyPixMultiplier[]} = {\n  'MobileNetV1': [0.50, 0.75, 1.0],\n  'ResNet50': [1.0]\n};\nconst VALID_QUANT_BYTES: BodyPixQuantBytes[] = [1, 2, 4];\n\nfunction validateModelConfig(config: ModelConfig): ModelConfig {\n  config = config || MOBILENET_V1_CONFIG;\n\n  if (config.architecture == null) {\n    config.architecture = 'MobileNetV1';\n  }\n  if (VALID_ARCHITECTURE.indexOf(config.architecture) < 0) {\n    throw new Error(\n        `Invalid architecture ${config.architecture}. ` +\n        `Should be one of ${VALID_ARCHITECTURE}`);\n  }\n  if (config.outputStride == null) {\n    config.outputStride = 16;\n  }\n  if (VALID_STRIDE[config.architecture].indexOf(config.outputStride) < 0) {\n    throw new Error(\n        `Invalid outputStride ${config.outputStride}. ` +\n        `Should be one of ${VALID_STRIDE[config.architecture]} ` +\n        `for architecture ${config.architecture}.`);\n  }\n\n  if (config.multiplier == null) {\n    config.multiplier = 1.0;\n  }\n  if (VALID_MULTIPLIER[config.architecture].indexOf(config.multiplier) < 0) {\n    throw new Error(\n        `Invalid multiplier ${config.multiplier}. ` +\n        `Should be one of ${VALID_MULTIPLIER[config.architecture]} ` +\n        `for architecture ${config.architecture}.`);\n  }\n\n  if (config.quantBytes == null) {\n    config.quantBytes = 4;\n  }\n  if (VALID_QUANT_BYTES.indexOf(config.quantBytes) < 0) {\n    throw new Error(\n        `Invalid quantBytes ${config.quantBytes}. ` +\n        `Should be one of ${VALID_QUANT_BYTES} ` +\n        `for architecture ${config.architecture}.`);\n  }\n\n  return config;\n}\n\n/**\n * BodyPix inference is configurable using the following config dictionary.\n *\n * `flipHorizontal`: If the left-right keypoint of poses/part segmentation\n * should be flipped/mirrored horizontally. This should be set to true for\n * videos where the video is by default flipped horizontally (i.e. a webcam),\n * and you want the person & body part segmentation to be returned in the proper\n * orientation.\n *\n * `internalResolution`: Defaults to 'medium'. The internal resolution\n * percentage that the input is resized to before inference. The larger the\n * internalResolution the more accurate the model at the cost of slower\n * prediction times. Available values are 'low', 'medium', 'high', 'full', or a\n * percentage value between 0 and 1. The values 'low', 'medium', 'high', and\n * 'full' map to 0.25, 0.5, 0.75, and 1.0 correspondingly.\n *\n * `segmentationThreshold`: The minimum that segmentation values must\n * have to be considered part of the person. Affects the generation of the\n * segmentation mask. More specifically, it is the threshold used to binarize\n * the intermediate person segmentation probability. The probability of each\n * pixel belongs to a person is in range [0, 1]. If the probability is greater\n * than the `segmentationThreshold`, it will be set to 1 otherwise 0.\n *\n */\nexport interface InferenceConfig {\n  flipHorizontal?: boolean;\n  internalResolution?: BodyPixInternalResolution;\n  segmentationThreshold?: number;\n}\n\n/**\n * Person Inference Config\n *\n * `maxDetections`: Defaults to 10. Maximum number of person pose detections per\n * image.\n *\n * `scoreThreshold`: Defaults to 0.4. Only return person pose that have root\n * part score greater or equal to this value.\n *\n * `nmsRadius`: Defaults to 20. Non-maximum suppression part distance in pixels.\n * It needs to be strictly positive. Two pose keypoints suppress each other if\n * they are less than `nmsRadius` pixels away.\n */\nexport interface PersonInferenceConfig extends InferenceConfig {\n  maxDetections?: number;\n  scoreThreshold?: number;\n  nmsRadius?: number;\n}\n\n/**\n * Multiple Person Instance Inference Config\n *\n * `maxDetections`: Defaults to 10. Maximum number of returned instance\n * segmentation and pose detections per image.\n *\n * `scoreThreshold`: Defaults to 0.4. Only returns and uses person\n * poses for instance segmentation assignment when the pose has root part score\n * greater or equal to this value.\n *\n * `nmsRadius`: Defaults to 20. Non-maximum suppression part distance in pixels.\n * It needs to be strictly positive. Two parts suppress each other if they are\n * less than `nmsRadius` pixels away.\n *\n * `minKeypointScore`: Default to 0.3. Keypoints above the score are used\n * for matching and assigning segmentation mask to each person.\n *\n * `refineSteps`: Default to 10. The number of refinement steps used when\n * assigning the instance segmentation. It needs to be strictly positive. The\n * larger the higher the accuracy and slower the inference.\n *\n */\nexport interface MultiPersonInstanceInferenceConfig extends InferenceConfig {\n  maxDetections?: number;\n  scoreThreshold?: number;\n  nmsRadius?: number;\n  minKeypointScore?: number;\n  refineSteps?: number;\n}\n\nexport const PERSON_INFERENCE_CONFIG: PersonInferenceConfig = {\n  flipHorizontal: false,\n  internalResolution: 'medium',\n  segmentationThreshold: 0.7,\n  maxDetections: 10,\n  scoreThreshold: 0.4,\n  nmsRadius: 20,\n};\n\nexport const MULTI_PERSON_INSTANCE_INFERENCE_CONFIG:\n    MultiPersonInstanceInferenceConfig = {\n      flipHorizontal: false,\n      internalResolution: 'medium',\n      segmentationThreshold: 0.7,\n      maxDetections: 10,\n      scoreThreshold: 0.4,\n      nmsRadius: 20,\n      minKeypointScore: 0.3,\n      refineSteps: 10\n    };\n\nfunction validatePersonInferenceConfig(config: PersonInferenceConfig) {\n  const {segmentationThreshold, maxDetections, scoreThreshold, nmsRadius} =\n      config;\n\n  if (segmentationThreshold < 0.0 || segmentationThreshold > 1.0) {\n    throw new Error(\n        `segmentationThreshold ${segmentationThreshold}. ` +\n        `Should be in range [0.0, 1.0]`);\n  }\n\n  if (maxDetections <= 0) {\n    throw new Error(\n        `Invalid maxDetections ${maxDetections}. ` +\n        `Should be > 0`);\n  }\n\n  if (scoreThreshold < 0.0 || scoreThreshold > 1.0) {\n    throw new Error(\n        `Invalid scoreThreshold ${scoreThreshold}. ` +\n        `Should be in range [0.0, 1.0]`);\n  }\n\n  if (nmsRadius <= 0) {\n    throw new Error(`Invalid nmsRadius ${nmsRadius}.`);\n  }\n}\n\nfunction validateMultiPersonInstanceInferenceConfig(\n    config: MultiPersonInstanceInferenceConfig) {\n  const {\n    segmentationThreshold,\n    maxDetections,\n    scoreThreshold,\n    nmsRadius,\n    minKeypointScore,\n    refineSteps\n  } = config;\n\n  if (segmentationThreshold < 0.0 || segmentationThreshold > 1.0) {\n    throw new Error(\n        `segmentationThreshold ${segmentationThreshold}. ` +\n        `Should be in range [0.0, 1.0]`);\n  }\n\n  if (maxDetections <= 0) {\n    throw new Error(\n        `Invalid maxDetections ${maxDetections}. ` +\n        `Should be > 0`);\n  }\n\n  if (scoreThreshold < 0.0 || scoreThreshold > 1.0) {\n    throw new Error(\n        `Invalid scoreThreshold ${scoreThreshold}. ` +\n        `Should be in range [0.0, 1.0]`);\n  }\n\n  if (nmsRadius <= 0) {\n    throw new Error(`Invalid nmsRadius ${nmsRadius}.`);\n  }\n\n  if (minKeypointScore < 0 || minKeypointScore > 1) {\n    throw new Error(\n        `Invalid minKeypointScore ${minKeypointScore}.` +\n        `Should be in range [0.0, 1.0]`);\n  }\n\n  if (refineSteps <= 0 || refineSteps > 20) {\n    throw new Error(\n        `Invalid refineSteps ${refineSteps}.` +\n        `Should be in range [1, 20]`);\n  }\n}\n\nexport class BodyPix {\n  baseModel: BaseModel;\n\n  constructor(net: BaseModel) {\n    this.baseModel = net;\n  }\n\n  private predictForPersonSegmentation(input: tf.Tensor3D): {\n    segmentLogits: tf.Tensor3D,\n    heatmapScores: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D,\n  } {\n    const {\n      segmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n    } = this.baseModel.predict(input);\n    return {\n      segmentLogits: segmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n    };\n  }\n\n  private predictForPersonSegmentationAndPart(input: tf.Tensor3D): {\n    segmentLogits: tf.Tensor3D,\n    partHeatmapLogits: tf.Tensor3D,\n    heatmapScores: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D,\n  } {\n    const {\n      segmentation,\n      partHeatmaps,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd\n    } = this.baseModel.predict(input);\n    return {\n      segmentLogits: segmentation,\n      partHeatmapLogits: partHeatmaps,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n    };\n  }\n\n  private predictForMultiPersonInstanceSegmentationAndPart(input: tf.Tensor3D):\n      {\n        segmentLogits: tf.Tensor3D,\n        longOffsets: tf.Tensor3D,\n        heatmapScores: tf.Tensor3D,\n        offsets: tf.Tensor3D,\n        displacementFwd: tf.Tensor3D,\n        displacementBwd: tf.Tensor3D,\n        partHeatmaps: tf.Tensor3D\n      } {\n    const {\n      segmentation,\n      longOffsets,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n      partHeatmaps,\n    } = this.baseModel.predict(input);\n    return {\n      segmentLogits: segmentation,\n      longOffsets,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n      partHeatmaps\n    };\n  }\n\n  /**\n   * Given an image with people, returns a dictionary of all intermediate\n   * tensors including: 1) a binary array with 1 for the pixels that are part of\n   * the person, and 0 otherwise, 2) heatmapScores, 3) offsets, and 4) paddings.\n   *\n   * @param input ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)\n   * The input image to feed through the network.\n   *\n   * @param internalResolution Defaults to 'medium'. The internal resolution\n   * that the input is resized to before inference. The larger the\n   * internalResolution the more accurate the model at the cost of slower\n   * prediction times. Available values are 'low', 'medium', 'high', 'full', or\n   * a percentage value between 0 and 1. The values 'low', 'medium', 'high', and\n   * 'full' map to 0.25, 0.5, 0.75, and 1.0 correspondingly.\n   *\n   * @param segmentationThreshold The minimum that segmentation values must have\n   * to be considered part of the person. Affects the generation of the\n   * segmentation mask.\n   *\n   * @return A dictionary containing `segmentation`, `heatmapScores`, `offsets`,\n   * and `padding`:\n   * - `segmentation`: A 2d Tensor with 1 for the pixels that are part of the\n   * person, and 0 otherwise. The width and height correspond to the same\n   * dimensions of the input image.\n   * - `heatmapScores`: A 3d Tensor of the keypoint heatmaps used by\n   * pose estimation decoding.\n   * - `offsets`: A 3d Tensor of the keypoint offsets used by pose\n   * estimation decoding.\n   * - `displacementFwd`: A 3d Tensor of the keypoint forward displacement used\n   * by pose estimation decoding.\n   * - `displacementBwd`: A 3d Tensor of the keypoint backward displacement used\n   * by pose estimation decoding.\n   * - `padding`: The padding (unit pixels) being applied to the input image\n   * before it is fed into the model.\n   */\n  segmentPersonActivation(\n      input: BodyPixInput, internalResolution: BodyPixInternalResolution,\n      segmentationThreshold = 0.5): {\n    segmentation: tf.Tensor2D,\n    heatmapScores: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D,\n    padding: Padding,\n    internalResolutionHeightAndWidth: [number, number]\n  } {\n    const [height, width] = getInputSize(input);\n    const internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(\n        internalResolution, this.baseModel.outputStride, [height, width]);\n    const {resized, padding} =\n        padAndResizeTo(input, internalResolutionHeightAndWidth);\n\n    const {\n      segmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd\n    } = tf.tidy(() => {\n      const {\n        segmentLogits,\n        heatmapScores,\n        offsets,\n        displacementFwd,\n        displacementBwd\n      } = this.predictForPersonSegmentation(resized);\n\n      const [resizedHeight, resizedWidth] = resized.shape;\n\n      const scaledSegmentScores = scaleAndCropToInputTensorShape(\n          segmentLogits, [height, width], [resizedHeight, resizedWidth],\n          [[padding.top, padding.bottom], [padding.left, padding.right]],\n          APPLY_SIGMOID_ACTIVATION);\n\n      return {\n        segmentation:\n            toMaskTensor(scaledSegmentScores.squeeze(), segmentationThreshold),\n        heatmapScores,\n        offsets,\n        displacementFwd,\n        displacementBwd,\n      };\n    });\n    resized.dispose();\n    return {\n      segmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n      padding,\n      internalResolutionHeightAndWidth\n    };\n  }\n\n  /**\n   * Given an image with many people, returns a PersonSegmentation dictionary\n   * that contains the segmentation mask for all people and a single pose.\n   *\n   * Note: The segmentation mask returned by this method covers all people but\n   * the pose works well for one person. If you want to estimate instance-level\n   * multiple person segmentation & pose for each person, use\n   * `segmentMultiPerson` instead.\n   *\n   * @param input ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)\n   * The input image to feed through the network.\n   *\n   * @param config PersonInferenceConfig object that contains\n   * parameters for the BodyPix inference using person decoding.\n   *\n   * @return A SemanticPersonSegmentation dictionary that contains height,\n   * width, the flattened binary segmentation mask and the poses for all people.\n   * The width and height correspond to the same dimensions of the input image.\n   * - `height`: The height of the segmentation data in pixel unit.\n   * - `width`: The width of the segmentation data in pixel unit.\n   * - `data`: The flattened Uint8Array of segmentation data. 1 means the pixel\n   * belongs to a person and 0 means the pixel doesn't belong to a person. The\n   * size of the array is equal to `height` x `width` in row-major order.\n   * - `allPoses`: The 2d poses of all people.\n   */\n  async segmentPerson(\n      input: BodyPixInput,\n      config: PersonInferenceConfig = PERSON_INFERENCE_CONFIG):\n      Promise<SemanticPersonSegmentation> {\n    config = {...PERSON_INFERENCE_CONFIG, ...config};\n\n    validatePersonInferenceConfig(config);\n\n    const {\n      segmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n      padding,\n      internalResolutionHeightAndWidth\n    } =\n        this.segmentPersonActivation(\n            input, config.internalResolution, config.segmentationThreshold);\n\n    const [height, width] = segmentation.shape;\n\n    const result = await segmentation.data() as Uint8Array;\n    segmentation.dispose();\n\n    const [scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf] =\n        await toTensorBuffers3D(\n            [heatmapScores, offsets, displacementFwd, displacementBwd]);\n\n    let poses = decodeMultiplePoses(\n        scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf,\n        this.baseModel.outputStride, config.maxDetections,\n        config.scoreThreshold, config.nmsRadius);\n\n    poses = scaleAndFlipPoses(\n        poses, [height, width], internalResolutionHeightAndWidth, padding,\n        FLIP_POSES_AFTER_SCALING);\n\n    heatmapScores.dispose();\n    offsets.dispose();\n    displacementFwd.dispose();\n    displacementBwd.dispose();\n\n    return {height, width, data: result, allPoses: poses};\n  }\n\n  /**\n   * Given an image with multiple people, returns an *array* of\n   * PersonSegmentation object. Each element in the array corresponding to one\n   * of the people in the input image. In other words, it predicts\n   * instance-level multiple person segmentation & pose for each person.\n   *\n   * The model does standard ImageNet pre-processing before inferring through\n   * the model. The image pixels should have values [0-255].\n   *\n   * @param input\n   * ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement) The input\n   * image to feed through the network.\n   *\n   * @param config MultiPersonInferenceConfig object that contains\n   * parameters for the BodyPix inference using multi-person decoding.\n   *\n   * @return An array of PersonSegmentation object, each containing a width,\n   * height, a binary array (1 for the pixels that are part of the\n   * person, and 0 otherwise) and 2D pose. The array size corresponds to the\n   * number of pixels in the image. The width and height correspond to the\n   * dimensions of the image the binary array is shaped to, which are the same\n   * dimensions of the input image.\n   */\n  async segmentMultiPerson(\n      input: BodyPixInput,\n      config: MultiPersonInstanceInferenceConfig =\n          MULTI_PERSON_INSTANCE_INFERENCE_CONFIG):\n      Promise<PersonSegmentation[]> {\n    config = {...MULTI_PERSON_INSTANCE_INFERENCE_CONFIG, ...config};\n    validateMultiPersonInstanceInferenceConfig(config);\n    const [height, width] = getInputSize(input);\n    const internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(\n        config.internalResolution, this.baseModel.outputStride,\n        [height, width]);\n\n    const {resized, padding} =\n        padAndResizeTo(input, internalResolutionHeightAndWidth);\n    const {\n      segmentation,\n      longOffsets,\n      heatmapScoresRaw,\n      offsetsRaw,\n      displacementFwdRaw,\n      displacementBwdRaw,\n    } = tf.tidy(() => {\n      const {\n        segmentLogits,\n        longOffsets,\n        heatmapScores,\n        offsets,\n        displacementFwd,\n        displacementBwd,\n      } = this.predictForMultiPersonInstanceSegmentationAndPart(resized);\n      const scaledSegmentScores = scaleAndCropToInputTensorShape(\n          segmentLogits, [height, width], internalResolutionHeightAndWidth,\n          [[padding.top, padding.bottom], [padding.left, padding.right]],\n          APPLY_SIGMOID_ACTIVATION);\n      const longOffsetsResized = false;\n      let scaledLongOffsets;\n      if (longOffsetsResized) {\n        scaledLongOffsets = scaleAndCropToInputTensorShape(\n            longOffsets, [height, width], internalResolutionHeightAndWidth,\n            [[padding.top, padding.bottom], [padding.left, padding.right]],\n            APPLY_SIGMOID_ACTIVATION);\n      } else {\n        scaledLongOffsets = longOffsets;\n      }\n\n      const segmentation = toMaskTensor(\n          scaledSegmentScores.squeeze(), config.segmentationThreshold);\n\n      return {\n        segmentation,\n        longOffsets: scaledLongOffsets,\n        heatmapScoresRaw: heatmapScores,\n        offsetsRaw: offsets,\n        displacementFwdRaw: displacementFwd,\n        displacementBwdRaw: displacementBwd,\n      };\n    });\n\n    const [scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf] =\n        await toTensorBuffers3D([\n          heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw\n        ]);\n\n    let poses = decodeMultiplePoses(\n        scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf,\n        this.baseModel.outputStride, config.maxDetections,\n        config.scoreThreshold, config.nmsRadius);\n\n    poses = scaleAndFlipPoses(\n        poses, [height, width], internalResolutionHeightAndWidth, padding,\n        FLIP_POSES_AFTER_SCALING);\n\n    const instanceMasks = await decodePersonInstanceMasks(\n        segmentation, longOffsets, poses, height, width,\n        this.baseModel.outputStride, internalResolutionHeightAndWidth, padding,\n        config.scoreThreshold, config.refineSteps, config.minKeypointScore,\n        config.maxDetections);\n\n    resized.dispose();\n    segmentation.dispose();\n    longOffsets.dispose();\n    heatmapScoresRaw.dispose();\n    offsetsRaw.dispose();\n    displacementFwdRaw.dispose();\n    displacementBwdRaw.dispose();\n\n    return instanceMasks;\n  }\n\n  /**\n   * Given an image with many people, returns a dictionary containing: height,\n   * width, a tensor with a part id from 0-24 for the pixels that are\n   * part of a corresponding body part, and -1 otherwise. This does standard\n   * ImageNet pre-processing before inferring through the model.  The image\n   * should pixels should have values [0-255].\n   *\n   * @param input ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)\n   * The input image to feed through the network.\n   *\n   * @param internalResolution Defaults to 'medium'. The internal resolution\n   * percentage that the input is resized to before inference. The larger the\n   * internalResolution the more accurate the model at the cost of slower\n   * prediction times. Available values are 'low', 'medium', 'high', 'full', or\n   * a percentage value between 0 and 1. The values 'low', 'medium', 'high', and\n   * 'full' map to 0.25, 0.5, 0.75, and 1.0 correspondingly.\n   *\n   * @param segmentationThreshold The minimum that segmentation values must have\n   * to be considered part of the person.  Affects the clipping of the colored\n   * part image.\n   *\n   * @return  A dictionary containing `partSegmentation`, `heatmapScores`,\n   * `offsets`, and `padding`:\n   * - `partSegmentation`: A 2d Tensor with a part id from 0-24 for\n   * the pixels that are part of a corresponding body part, and -1 otherwise.\n   * - `heatmapScores`: A 3d Tensor of the keypoint heatmaps used by\n   * single-person pose estimation decoding.\n   * - `offsets`: A 3d Tensor of the keypoint offsets used by single-person pose\n   * estimation decoding.\n   * - `displacementFwd`: A 3d Tensor of the keypoint forward displacement\n   * used by pose estimation decoding.\n   * - `displacementBwd`: A 3d Tensor of the keypoint backward displacement used\n   * by pose estimation decoding.\n   * - `padding`: The padding (unit pixels) being applied to the input image\n   * before it is fed into the model.\n   */\n  segmentPersonPartsActivation(\n      input: BodyPixInput, internalResolution: BodyPixInternalResolution,\n      segmentationThreshold = 0.5): {\n    partSegmentation: tf.Tensor2D,\n    heatmapScores: tf.Tensor3D,\n    offsets: tf.Tensor3D,\n    displacementFwd: tf.Tensor3D,\n    displacementBwd: tf.Tensor3D,\n    padding: Padding,\n    internalResolutionHeightAndWidth: [number, number]\n  } {\n    const [height, width] = getInputSize(input);\n    const internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(\n        internalResolution, this.baseModel.outputStride, [height, width]);\n    const {\n      resized,\n      padding,\n    } = padAndResizeTo(input, internalResolutionHeightAndWidth);\n\n    const {\n      partSegmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd\n    } = tf.tidy(() => {\n      const {\n        segmentLogits,\n        partHeatmapLogits,\n        heatmapScores,\n        offsets,\n        displacementFwd,\n        displacementBwd\n      } = this.predictForPersonSegmentationAndPart(resized);\n\n      const [resizedHeight, resizedWidth] = resized.shape;\n\n      const scaledSegmentScores = scaleAndCropToInputTensorShape(\n          segmentLogits, [height, width], [resizedHeight, resizedWidth],\n          [[padding.top, padding.bottom], [padding.left, padding.right]],\n          APPLY_SIGMOID_ACTIVATION);\n\n      const scaledPartHeatmapScore = scaleAndCropToInputTensorShape(\n          partHeatmapLogits, [height, width], [resizedHeight, resizedWidth],\n          [[padding.top, padding.bottom], [padding.left, padding.right]],\n          APPLY_SIGMOID_ACTIVATION);\n      const segmentation =\n          toMaskTensor(scaledSegmentScores.squeeze(), segmentationThreshold);\n      return {\n        partSegmentation:\n            decodePartSegmentation(segmentation, scaledPartHeatmapScore),\n        heatmapScores,\n        offsets,\n        displacementFwd,\n        displacementBwd,\n      };\n    });\n    resized.dispose();\n    return {\n      partSegmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n      padding,\n      internalResolutionHeightAndWidth\n    };\n  }\n\n  /**\n   * Given an image with many people, returns a PartSegmentation dictionary that\n   * contains the body part segmentation mask for all people and a single pose.\n   *\n   * Note: The body part segmentation mask returned by this method covers all\n   * people but the pose works well when there is one person. If you want to\n   * estimate instance-level multiple person body part segmentation & pose for\n   * each person, use `segmentMultiPersonParts` instead.\n   *\n   * @param input ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)\n   * The input image to feed through the network.\n   *\n   * @param config PersonInferenceConfig object that contains\n   * parameters for the BodyPix inference using single person decoding.\n   *\n   * @return A SemanticPartSegmentation dictionary that contains height, width,\n   * the flattened binary segmentation mask and the pose for the person. The\n   * width and height correspond to the same dimensions of the input image.\n   * - `height`: The height of the person part segmentation data in pixel unit.\n   * - `width`: The width of the person part segmentation data in pixel unit.\n   * - `data`: The flattened Int32Array of person part segmentation data with a\n   * part id from 0-24 for the pixels that are part of a corresponding body\n   * part, and -1 otherwise. The size of the array is equal to `height` x\n   * `width` in row-major order.\n   * - `allPoses`: The 2d poses of all people.\n   */\n  async segmentPersonParts(\n      input: BodyPixInput,\n      config: PersonInferenceConfig = PERSON_INFERENCE_CONFIG):\n      Promise<SemanticPartSegmentation> {\n    config = {...PERSON_INFERENCE_CONFIG, ...config};\n\n    validatePersonInferenceConfig(config);\n    const {\n      partSegmentation,\n      heatmapScores,\n      offsets,\n      displacementFwd,\n      displacementBwd,\n      padding,\n      internalResolutionHeightAndWidth\n    } =\n        this.segmentPersonPartsActivation(\n            input, config.internalResolution, config.segmentationThreshold);\n\n    const [height, width] = partSegmentation.shape;\n    const data = await partSegmentation.data() as Int32Array;\n    partSegmentation.dispose();\n\n    const [scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf] =\n        await toTensorBuffers3D(\n            [heatmapScores, offsets, displacementFwd, displacementBwd]);\n\n    let poses = decodeMultiplePoses(\n        scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf,\n        this.baseModel.outputStride, config.maxDetections,\n        config.scoreThreshold, config.nmsRadius);\n\n    poses = scaleAndFlipPoses(\n        poses, [height, width], internalResolutionHeightAndWidth, padding,\n        FLIP_POSES_AFTER_SCALING);\n\n    heatmapScores.dispose();\n    offsets.dispose();\n    displacementFwd.dispose();\n    displacementBwd.dispose();\n\n    return {height, width, data, allPoses: poses};\n  }\n\n  /**\n   * Given an image with multiple people, returns an *array* of PartSegmentation\n   * object. Each element in the array corresponding to one\n   * of the people in the input image. In other words, it predicts\n   * instance-level multiple person body part segmentation & pose for each\n   * person.\n   *\n   * This does standard ImageNet pre-processing before inferring through\n   * the model. The image pixels should have values [0-255].\n   *\n   * @param input\n   * ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement) The input\n   * image to feed through the network.\n   *\n   * @param config MultiPersonInferenceConfig object that contains\n   * parameters for the BodyPix inference using multi-person decoding.\n   *\n   * @return An array of PartSegmentation object, each containing a width,\n   * height, a flattened array (with part id from 0-24 for the pixels that are\n   * part of a corresponding body part, and -1 otherwise) and 2D pose. The width\n   * and height correspond to the dimensions of the image. Each flattened part\n   * segmentation array size is equal to `height` x `width`.\n   */\n  async segmentMultiPersonParts(\n      input: BodyPixInput,\n      config: MultiPersonInstanceInferenceConfig =\n          MULTI_PERSON_INSTANCE_INFERENCE_CONFIG): Promise<PartSegmentation[]> {\n    config = {...MULTI_PERSON_INSTANCE_INFERENCE_CONFIG, ...config};\n\n    validateMultiPersonInstanceInferenceConfig(config);\n    const [height, width] = getInputSize(input);\n    const internalResolutionHeightAndWidth = toInputResolutionHeightAndWidth(\n        config.internalResolution, this.baseModel.outputStride,\n        [height, width]);\n    const {resized, padding} =\n        padAndResizeTo(input, internalResolutionHeightAndWidth);\n    const {\n      segmentation,\n      longOffsets,\n      heatmapScoresRaw,\n      offsetsRaw,\n      displacementFwdRaw,\n      displacementBwdRaw,\n      partSegmentation,\n    } = tf.tidy(() => {\n      const {\n        segmentLogits,\n        longOffsets,\n        heatmapScores,\n        offsets,\n        displacementFwd,\n        displacementBwd,\n        partHeatmaps\n      } = this.predictForMultiPersonInstanceSegmentationAndPart(resized);\n\n      // decoding with scaling.\n      const scaledSegmentScores = scaleAndCropToInputTensorShape(\n          segmentLogits, [height, width], internalResolutionHeightAndWidth,\n          [[padding.top, padding.bottom], [padding.left, padding.right]],\n          APPLY_SIGMOID_ACTIVATION);\n\n      // decoding with scaling.\n      const scaledPartSegmentationScores = scaleAndCropToInputTensorShape(\n          partHeatmaps, [height, width], internalResolutionHeightAndWidth,\n          [[padding.top, padding.bottom], [padding.left, padding.right]],\n          APPLY_SIGMOID_ACTIVATION);\n\n      const scaledLongOffsets = longOffsets;\n      const segmentation = toMaskTensor(\n          scaledSegmentScores.squeeze(), config.segmentationThreshold);\n      const partSegmentation =\n          decodeOnlyPartSegmentation(scaledPartSegmentationScores);\n      return {\n        segmentation,\n        longOffsets: scaledLongOffsets,\n        heatmapScoresRaw: heatmapScores,\n        offsetsRaw: offsets,\n        displacementFwdRaw: displacementFwd,\n        displacementBwdRaw: displacementBwd,\n        partSegmentation\n      };\n    });\n\n    const [scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf] =\n        await toTensorBuffers3D([\n          heatmapScoresRaw, offsetsRaw, displacementFwdRaw, displacementBwdRaw\n        ]);\n\n    let poses = decodeMultiplePoses(\n        scoresBuf, offsetsBuf, displacementsFwdBuf, displacementsBwdBuf,\n        this.baseModel.outputStride, config.maxDetections,\n        config.scoreThreshold, config.nmsRadius);\n\n    poses = scaleAndFlipPoses(\n        poses, [height, width], internalResolutionHeightAndWidth, padding,\n        FLIP_POSES_AFTER_SCALING);\n\n    const instanceMasks = await decodePersonInstancePartMasks(\n        segmentation, longOffsets, partSegmentation, poses, height, width,\n        this.baseModel.outputStride, internalResolutionHeightAndWidth, padding,\n        config.scoreThreshold, config.refineSteps, config.minKeypointScore,\n        config.maxDetections);\n\n    resized.dispose();\n    segmentation.dispose();\n    longOffsets.dispose();\n    heatmapScoresRaw.dispose();\n    offsetsRaw.dispose();\n    displacementFwdRaw.dispose();\n    displacementBwdRaw.dispose();\n    partSegmentation.dispose();\n\n    return instanceMasks;\n  }\n\n  public dispose() {\n    this.baseModel.dispose();\n  }\n}\n\n/**\n * Loads the MobileNet BodyPix model.\n */\nasync function loadMobileNet(config: ModelConfig): Promise<BodyPix> {\n  const outputStride = config.outputStride;\n  const quantBytes = config.quantBytes;\n  const multiplier = config.multiplier;\n  if (tf == null) {\n    throw new Error(\n        `Cannot find TensorFlow.js. If you are using a <script> tag, please ` +\n        `also include @tensorflow/tfjs on the page before using this\n        model.`);\n  }\n\n  const url = mobileNetSavedModel(outputStride, multiplier, quantBytes);\n  const graphModel = await tfconv.loadGraphModel(config.modelUrl || url);\n  const mobilenet = new MobileNet(graphModel, outputStride);\n  return new BodyPix(mobilenet);\n}\n\n/**\n * Loads the ResNet BodyPix model.\n */\nasync function loadResNet(config: ModelConfig): Promise<BodyPix> {\n  const outputStride = config.outputStride;\n  const quantBytes = config.quantBytes;\n  if (tf == null) {\n    throw new Error(\n        `Cannot find TensorFlow.js. If you are using a <script> tag, please ` +\n        `also include @tensorflow/tfjs on the page before using this\n        model.`);\n  }\n\n  const url = resNet50SavedModel(outputStride, quantBytes);\n  const graphModel = await tfconv.loadGraphModel(config.modelUrl || url);\n  const resnet = new ResNet(graphModel, outputStride);\n  return new BodyPix(resnet);\n}\n\n/**\n * Loads the BodyPix model instance from a checkpoint, with the ResNet\n * or MobileNet architecture. The model to be loaded is configurable using the\n * config dictionary ModelConfig. Please find more details in the\n * documentation of the ModelConfig.\n *\n * @param config ModelConfig dictionary that contains parameters for\n * the BodyPix loading process. Please find more details of each parameters\n * in the documentation of the ModelConfig interface. The predefined\n * `MOBILENET_V1_CONFIG` and `RESNET_CONFIG` can also be used as references\n * for defining your customized config.\n */\nexport async function load(config: ModelConfig = MOBILENET_V1_CONFIG):\n    Promise<BodyPix> {\n  config = validateModelConfig(config);\n  if (config.architecture === 'ResNet50') {\n    return loadResNet(config);\n  } else if (config.architecture === 'MobileNetV1') {\n    return loadMobileNet(config);\n  } else {\n    return null;\n  }\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// method copied from bGlur in https://codepen.io/zhaojun/pen/zZmRQe\nexport function cpuBlur(\n    canvas: HTMLCanvasElement,\n    image: HTMLImageElement|HTMLVideoElement|HTMLCanvasElement, blur: number) {\n  const ctx = canvas.getContext('2d');\n\n  let sum = 0;\n  const delta = 5;\n  const alphaLeft = 1 / (2 * Math.PI * delta * delta);\n  const step = blur < 3 ? 1 : 2;\n  for (let y = -blur; y <= blur; y += step) {\n    for (let x = -blur; x <= blur; x += step) {\n      const weight =\n          alphaLeft * Math.exp(-(x * x + y * y) / (2 * delta * delta));\n      sum += weight;\n    }\n  }\n  for (let y = -blur; y <= blur; y += step) {\n    for (let x = -blur; x <= blur; x += step) {\n      ctx.globalAlpha = alphaLeft *\n          Math.exp(-(x * x + y * y) / (2 * delta * delta)) / sum * blur;\n      ctx.drawImage(image, x, y);\n    }\n  }\n  ctx.globalAlpha = 1;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {cpuBlur} from './blur';\nimport {Color, PartSegmentation, PersonSegmentation} from './types';\nimport {SemanticPartSegmentation, SemanticPersonSegmentation} from './types';\nimport {getInputSize} from './util';\n\nconst offScreenCanvases: {[name: string]: HTMLCanvasElement} = {};\n\ntype ImageType = HTMLImageElement|HTMLVideoElement|HTMLCanvasElement;\ntype HasDimensions = {\n  width: number,\n  height: number\n};\n\nfunction isSafari() {\n  return (/^((?!chrome|android).)*safari/i.test(navigator.userAgent));\n}\n\nfunction assertSameDimensions(\n    {width: widthA, height: heightA}: HasDimensions,\n    {width: widthB, height: heightB}: HasDimensions, nameA: string,\n    nameB: string) {\n  if (widthA !== widthB || heightA !== heightB) {\n    throw new Error(`error: dimensions must match. ${nameA} has dimensions ${\n        widthA}x${heightA}, ${nameB} has dimensions ${widthB}x${heightB}`);\n  }\n}\n\nfunction flipCanvasHorizontal(canvas: HTMLCanvasElement) {\n  const ctx = canvas.getContext('2d');\n  ctx.scale(-1, 1);\n  ctx.translate(-canvas.width, 0);\n}\n\nfunction drawWithCompositing(\n    ctx: CanvasRenderingContext2D, image: HTMLCanvasElement|ImageType,\n    compositOperation: string) {\n  ctx.globalCompositeOperation = compositOperation;\n  ctx.drawImage(image, 0, 0);\n}\n\nfunction createOffScreenCanvas(): HTMLCanvasElement {\n  const offScreenCanvas = document.createElement('canvas');\n  return offScreenCanvas;\n}\n\nfunction ensureOffscreenCanvasCreated(id: string): HTMLCanvasElement {\n  if (!offScreenCanvases[id]) {\n    offScreenCanvases[id] = createOffScreenCanvas();\n  }\n  return offScreenCanvases[id];\n}\n\nfunction drawAndBlurImageOnCanvas(\n    image: ImageType, blurAmount: number, canvas: HTMLCanvasElement) {\n  const {height, width} = image;\n  const ctx = canvas.getContext('2d');\n  canvas.width = width;\n  canvas.height = height;\n  ctx.clearRect(0, 0, width, height);\n  ctx.save();\n  if (isSafari()) {\n    cpuBlur(canvas, image, blurAmount);\n  } else {\n    // tslint:disable:no-any\n    (ctx as any).filter = `blur(${blurAmount}px)`;\n    ctx.drawImage(image, 0, 0, width, height);\n  }\n  ctx.restore();\n}\n\nfunction drawAndBlurImageOnOffScreenCanvas(\n    image: ImageType, blurAmount: number,\n    offscreenCanvasName: string): HTMLCanvasElement {\n  const canvas = ensureOffscreenCanvasCreated(offscreenCanvasName);\n  if (blurAmount === 0) {\n    renderImageToCanvas(image, canvas);\n  } else {\n    drawAndBlurImageOnCanvas(image, blurAmount, canvas);\n  }\n  return canvas;\n}\n\nfunction renderImageToCanvas(image: ImageType, canvas: HTMLCanvasElement) {\n  const {width, height} = image;\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d');\n\n  ctx.drawImage(image, 0, 0, width, height);\n}\n/**\n * Draw an image on a canvas\n */\nfunction renderImageDataToCanvas(image: ImageData, canvas: HTMLCanvasElement) {\n  canvas.width = image.width;\n  canvas.height = image.height;\n  const ctx = canvas.getContext('2d');\n\n  ctx.putImageData(image, 0, 0);\n}\n\nfunction renderImageDataToOffScreenCanvas(\n    image: ImageData, canvasName: string): HTMLCanvasElement {\n  const canvas = ensureOffscreenCanvasCreated(canvasName);\n  renderImageDataToCanvas(image, canvas);\n\n  return canvas;\n}\n\n/**\n * Given the output from estimating multi-person segmentation, generates an\n * image with foreground and background color at each pixel determined by the\n * corresponding binary segmentation value at the pixel from the output.  In\n * other words, pixels where there is a person will be colored with foreground\n * color and where there is not a person will be colored with background color.\n *\n * @param personOrPartSegmentation The output from\n * `segmentPerson`, `segmentMultiPerson`,\n * `segmentPersonParts` or `segmentMultiPersonParts`. They can\n * be SemanticPersonSegmentation object, an array of PersonSegmentation object,\n * SemanticPartSegmentation object, or an array of PartSegmentation object.\n *\n * @param foreground Default to {r:0, g:0, b:0, a: 0}. The foreground color\n * (r,g,b,a) for visualizing pixels that belong to people.\n *\n * @param background Default to {r:0, g:0, b:0, a: 255}. The background color\n * (r,g,b,a) for visualizing pixels that don't belong to people.\n *\n * @param drawContour Default to false. Whether to draw the contour around each\n * person's segmentation mask or body part mask.\n *\n * @param foregroundIds Default to [1]. The integer values that represent\n * foreground. For person segmentation, 1 is the foreground. For body part\n * segmentation, it can be a subset of all body parts ids.\n *\n * @returns An ImageData with the same width and height of\n * all the PersonSegmentation in multiPersonSegmentation, with opacity and\n * transparency at each pixel determined by the corresponding binary\n * segmentation value at the pixel from the output.\n */\nexport function toMask(\n    personOrPartSegmentation: SemanticPersonSegmentation|\n    SemanticPartSegmentation|PersonSegmentation[]|PartSegmentation[],\n    foreground: Color = {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 0\n    },\n    background: Color = {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 255\n    },\n    drawContour = false, foregroundIds: number[] = [1]): ImageData {\n  if (Array.isArray(personOrPartSegmentation) &&\n      personOrPartSegmentation.length === 0) {\n    return null;\n  }\n\n  let multiPersonOrPartSegmentation:\n      Array<SemanticPersonSegmentation|SemanticPartSegmentation|\n            PersonSegmentation|PartSegmentation>;\n\n  if (!Array.isArray(personOrPartSegmentation)) {\n    multiPersonOrPartSegmentation = [personOrPartSegmentation];\n  } else {\n    multiPersonOrPartSegmentation = personOrPartSegmentation;\n  }\n\n  const {width, height} = multiPersonOrPartSegmentation[0];\n  const bytes = new Uint8ClampedArray(width * height * 4);\n\n  function drawStroke(\n      bytes: Uint8ClampedArray, row: number, column: number, width: number,\n      radius: number, color: Color = {r: 0, g: 255, b: 255, a: 255}) {\n    for (let i = -radius; i <= radius; i++) {\n      for (let j = -radius; j <= radius; j++) {\n        if (i !== 0 && j !== 0) {\n          const n = (row + i) * width + (column + j);\n          bytes[4 * n + 0] = color.r;\n          bytes[4 * n + 1] = color.g;\n          bytes[4 * n + 2] = color.b;\n          bytes[4 * n + 3] = color.a;\n        }\n      }\n    }\n  }\n\n  function isSegmentationBoundary(\n      segmentationData: Uint8Array|Int32Array,\n      row: number,\n      column: number,\n      width: number,\n      foregroundIds: number[] = [1],\n      radius = 1,\n      ): boolean {\n    let numberBackgroundPixels = 0;\n    for (let i = -radius; i <= radius; i++) {\n      for (let j = -radius; j <= radius; j++) {\n        if (i !== 0 && j !== 0) {\n          const n = (row + i) * width + (column + j);\n          if (!foregroundIds.some(id => id === segmentationData[n])) {\n            numberBackgroundPixels += 1;\n          }\n        }\n      }\n    }\n    return numberBackgroundPixels > 0;\n  }\n\n  for (let i = 0; i < height; i += 1) {\n    for (let j = 0; j < width; j += 1) {\n      const n = i * width + j;\n      bytes[4 * n + 0] = background.r;\n      bytes[4 * n + 1] = background.g;\n      bytes[4 * n + 2] = background.b;\n      bytes[4 * n + 3] = background.a;\n      for (let k = 0; k < multiPersonOrPartSegmentation.length; k++) {\n        if (foregroundIds.some(\n                id => id === multiPersonOrPartSegmentation[k].data[n])) {\n          bytes[4 * n] = foreground.r;\n          bytes[4 * n + 1] = foreground.g;\n          bytes[4 * n + 2] = foreground.b;\n          bytes[4 * n + 3] = foreground.a;\n          const isBoundary = isSegmentationBoundary(\n              multiPersonOrPartSegmentation[k].data, i, j, width,\n              foregroundIds);\n          if (drawContour && i - 1 >= 0 && i + 1 < height && j - 1 >= 0 &&\n              j + 1 < width && isBoundary) {\n            drawStroke(bytes, i, j, width, 1);\n          }\n        }\n      }\n    }\n  }\n\n  return new ImageData(bytes, width, height);\n}\n\nconst RAINBOW_PART_COLORS: Array<[number, number, number]> = [\n  [110, 64, 170], [143, 61, 178], [178, 60, 178], [210, 62, 167],\n  [238, 67, 149], [255, 78, 125], [255, 94, 99],  [255, 115, 75],\n  [255, 140, 56], [239, 167, 47], [217, 194, 49], [194, 219, 64],\n  [175, 240, 91], [135, 245, 87], [96, 247, 96],  [64, 243, 115],\n  [40, 234, 141], [28, 219, 169], [26, 199, 194], [33, 176, 213],\n  [47, 150, 224], [65, 125, 224], [84, 101, 214], [99, 81, 195]\n];\n\n/**\n * Given the output from person body part segmentation (or multi-person\n * instance body part segmentation) and an array of colors indexed by part id,\n * generates an image with the corresponding color for each part at each pixel,\n * and white pixels where there is no part.\n *\n * @param partSegmentation The output from segmentPersonParts\n * or segmentMultiPersonParts. The former is a SemanticPartSegmentation\n * object and later is an array of PartSegmentation object.\n *\n * @param partColors A multi-dimensional array of rgb colors indexed by\n * part id.  Must have 24 colors, one for every part.\n *\n * @returns An ImageData with the same width and height of all the element in\n * multiPersonPartSegmentation, with the corresponding color for each part at\n * each pixel, and black pixels where there is no part.\n */\nexport function toColoredPartMask(\n    partSegmentation: SemanticPartSegmentation|PartSegmentation[],\n    partColors: Array<[number, number, number]> =\n        RAINBOW_PART_COLORS): ImageData {\n  if (Array.isArray(partSegmentation) && partSegmentation.length === 0) {\n    return null;\n  }\n\n  let multiPersonPartSegmentation;\n  if (!Array.isArray(partSegmentation)) {\n    multiPersonPartSegmentation = [partSegmentation];\n  } else {\n    multiPersonPartSegmentation = partSegmentation;\n  }\n  const {width, height} = multiPersonPartSegmentation[0];\n  const bytes = new Uint8ClampedArray(width * height * 4);\n\n  for (let i = 0; i < height * width; ++i) {\n    // invert mask.  Invert the segmentation mask.\n    const j = i * 4;\n    bytes[j + 0] = 255;\n    bytes[j + 1] = 255;\n    bytes[j + 2] = 255;\n    bytes[j + 3] = 255;\n    for (let k = 0; k < multiPersonPartSegmentation.length; k++) {\n      const partId = multiPersonPartSegmentation[k].data[i];\n      if (partId !== -1) {\n        const color = partColors[partId];\n        if (!color) {\n          throw new Error(`No color could be found for part id ${partId}`);\n        }\n        bytes[j + 0] = color[0];\n        bytes[j + 1] = color[1];\n        bytes[j + 2] = color[2];\n        bytes[j + 3] = 255;\n      }\n    }\n  }\n  return new ImageData(bytes, width, height);\n}\n\nconst CANVAS_NAMES = {\n  blurred: 'blurred',\n  blurredMask: 'blurred-mask',\n  mask: 'mask',\n  lowresPartMask: 'lowres-part-mask',\n};\n\n/**\n * Given an image and a maskImage of type ImageData, draws the image with the\n * mask on top of it onto a canvas.\n *\n * @param canvas The canvas to be drawn onto.\n *\n * @param image The original image to apply the mask to.\n *\n * @param maskImage An ImageData containing the mask.  Ideally this should be\n * generated by toMask or toColoredPartMask.\n *\n * @param maskOpacity The opacity of the mask when drawing it on top of the\n * image. Defaults to 0.7. Should be a float between 0 and 1.\n *\n * @param maskBlurAmount How many pixels to blur the mask by. Defaults to 0.\n * Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the result should be flipped horizontally.  Defaults\n * to false.\n */\nexport function drawMask(\n    canvas: HTMLCanvasElement, image: ImageType, maskImage: ImageData|null,\n    maskOpacity = 0.7, maskBlurAmount = 0, flipHorizontal = false) {\n  const [height, width] = getInputSize(image);\n  canvas.width = width;\n  canvas.height = height;\n\n  const ctx = canvas.getContext('2d');\n  ctx.save();\n  if (flipHorizontal) {\n    flipCanvasHorizontal(canvas);\n  }\n\n  ctx.drawImage(image, 0, 0);\n\n  ctx.globalAlpha = maskOpacity;\n  if (maskImage) {\n    assertSameDimensions({width, height}, maskImage, 'image', 'mask');\n\n    const mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);\n\n    const blurredMask = drawAndBlurImageOnOffScreenCanvas(\n        mask, maskBlurAmount, CANVAS_NAMES.blurredMask);\n    ctx.drawImage(blurredMask, 0, 0, width, height);\n  }\n  ctx.restore();\n}\n\n/**\n * Given an image and a maskImage of type ImageData, draws the image with the\n * pixelated mask on top of it onto a canvas.\n *\n * @param canvas The canvas to be drawn onto.\n *\n * @param image The original image to apply the mask to.\n *\n * @param maskImage An ImageData containing the mask.  Ideally this should be\n * generated by toColoredPartMask.\n *\n * @param maskOpacity The opacity of the mask when drawing it on top of the\n * image. Defaults to 0.7. Should be a float between 0 and 1.\n *\n * @param maskBlurAmount How many pixels to blur the mask by. Defaults to 0.\n * Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the result should be flipped horizontally.  Defaults\n * to false.\n *\n * @param pixelCellWidth The width of each pixel cell. Default to 10 px.\n */\nexport function drawPixelatedMask(\n    canvas: HTMLCanvasElement, image: ImageType, maskImage: ImageData,\n    maskOpacity = 0.7, maskBlurAmount = 0, flipHorizontal = false,\n    pixelCellWidth = 10.0) {\n  const [height, width] = getInputSize(image);\n  assertSameDimensions({width, height}, maskImage, 'image', 'mask');\n\n  const mask = renderImageDataToOffScreenCanvas(maskImage, CANVAS_NAMES.mask);\n  const blurredMask = drawAndBlurImageOnOffScreenCanvas(\n      mask, maskBlurAmount, CANVAS_NAMES.blurredMask);\n\n  canvas.width = blurredMask.width;\n  canvas.height = blurredMask.height;\n\n  const ctx = canvas.getContext('2d');\n  ctx.save();\n  if (flipHorizontal) {\n    flipCanvasHorizontal(canvas);\n  }\n\n  const offscreenCanvas =\n      ensureOffscreenCanvasCreated(CANVAS_NAMES.lowresPartMask);\n  const offscreenCanvasCtx = offscreenCanvas.getContext('2d');\n  offscreenCanvas.width = blurredMask.width * (1.0 / pixelCellWidth);\n  offscreenCanvas.height = blurredMask.height * (1.0 / pixelCellWidth);\n  offscreenCanvasCtx.drawImage(\n      blurredMask, 0, 0, blurredMask.width, blurredMask.height, 0, 0,\n      offscreenCanvas.width, offscreenCanvas.height);\n  ctx.imageSmoothingEnabled = false;\n  ctx.drawImage(\n      offscreenCanvas, 0, 0, offscreenCanvas.width, offscreenCanvas.height, 0,\n      0, canvas.width, canvas.height);\n\n  // Draws vertical grid lines that are `pixelCellWidth` apart from each other.\n  for (let i = 0; i < offscreenCanvas.width; i++) {\n    ctx.beginPath();\n    ctx.strokeStyle = '#ffffff';\n    ctx.moveTo(pixelCellWidth * i, 0);\n    ctx.lineTo(pixelCellWidth * i, canvas.height);\n    ctx.stroke();\n  }\n\n  // Draws horizontal grid lines that are `pixelCellWidth` apart from each\n  // other.\n  for (let i = 0; i < offscreenCanvas.height; i++) {\n    ctx.beginPath();\n    ctx.strokeStyle = '#ffffff';\n    ctx.moveTo(0, pixelCellWidth * i);\n    ctx.lineTo(canvas.width, pixelCellWidth * i);\n    ctx.stroke();\n  }\n\n  ctx.globalAlpha = 1.0 - maskOpacity;\n  ctx.drawImage(image, 0, 0, blurredMask.width, blurredMask.height);\n  ctx.restore();\n}\n\nfunction createPersonMask(\n    multiPersonSegmentation: PersonSegmentation[]|SemanticPersonSegmentation,\n    edgeBlurAmount: number): HTMLCanvasElement {\n  const backgroundMaskImage = toMask(\n      multiPersonSegmentation, {r: 0, g: 0, b: 0, a: 255},\n      {r: 0, g: 0, b: 0, a: 0});\n\n  const backgroundMask =\n      renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);\n  if (edgeBlurAmount === 0) {\n    return backgroundMask;\n  } else {\n    return drawAndBlurImageOnOffScreenCanvas(\n        backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask);\n  }\n}\n\n/**\n * Given a personSegmentation and an image, draws the image with its background\n * blurred onto the canvas.\n *\n * @param canvas The canvas to draw the background-blurred image onto.\n *\n * @param image The image to blur the background of and draw.\n *\n * @param personSegmentation A SemanticPersonSegmentation or an array of\n * PersonSegmentation object.\n *\n * @param backgroundBlurAmount How many pixels in the background blend into each\n * other.  Defaults to 3. Should be an integer between 1 and 20.\n *\n * @param edgeBlurAmount How many pixels to blur on the edge between the person\n * and the background by.  Defaults to 3. Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the output should be flipped horizontally.  Defaults\n * to false.\n */\nexport function drawBokehEffect(\n    canvas: HTMLCanvasElement, image: ImageType,\n    multiPersonSegmentation: SemanticPersonSegmentation|PersonSegmentation[],\n    backgroundBlurAmount = 3, edgeBlurAmount = 3, flipHorizontal = false) {\n  const blurredImage = drawAndBlurImageOnOffScreenCanvas(\n      image, backgroundBlurAmount, CANVAS_NAMES.blurred);\n  canvas.width = blurredImage.width;\n  canvas.height = blurredImage.height;\n\n  const ctx = canvas.getContext('2d');\n\n  if (Array.isArray(multiPersonSegmentation) &&\n      multiPersonSegmentation.length === 0) {\n    ctx.drawImage(blurredImage, 0, 0);\n    return;\n  }\n\n  const personMask = createPersonMask(multiPersonSegmentation, edgeBlurAmount);\n\n  ctx.save();\n  if (flipHorizontal) {\n    flipCanvasHorizontal(canvas);\n  }\n  // draw the original image on the final canvas\n  const [height, width] = getInputSize(image);\n  ctx.drawImage(image, 0, 0, width, height);\n\n  // \"destination-in\" - \"The existing canvas content is kept where both the\n  // new shape and existing canvas content overlap. Everything else is made\n  // transparent.\"\n  // crop what's not the person using the mask from the original image\n  drawWithCompositing(ctx, personMask, 'destination-in');\n  // \"destination-over\" - \"The existing canvas content is kept where both the\n  // new shape and existing canvas content overlap. Everything else is made\n  // transparent.\"\n  // draw the blurred background on top of the original image where it doesn't\n  // overlap.\n  drawWithCompositing(ctx, blurredImage, 'destination-over');\n  ctx.restore();\n}\n\nfunction createBodyPartMask(\n    multiPersonPartSegmentation: SemanticPartSegmentation|PartSegmentation[],\n    bodyPartIdsToMask: number[], edgeBlurAmount: number): HTMLCanvasElement {\n  const backgroundMaskImage = toMask(\n      multiPersonPartSegmentation, {r: 0, g: 0, b: 0, a: 0},\n      {r: 0, g: 0, b: 0, a: 255}, true, bodyPartIdsToMask);\n\n  const backgroundMask =\n      renderImageDataToOffScreenCanvas(backgroundMaskImage, CANVAS_NAMES.mask);\n  if (edgeBlurAmount === 0) {\n    return backgroundMask;\n  } else {\n    return drawAndBlurImageOnOffScreenCanvas(\n        backgroundMask, edgeBlurAmount, CANVAS_NAMES.blurredMask);\n  }\n}\n\n/**\n * Given a personSegmentation and an image, draws the image with its background\n * blurred onto the canvas.\n *\n * @param canvas The canvas to draw the background-blurred image onto.\n *\n * @param image The image to blur the background of and draw.\n *\n * @param partSegmentation A SemanticPartSegmentation or an array of\n * PartSegmentation object.\n *\n * @param bodyPartIdsToBlur Default to [0, 1] (left-face and right-face). An\n * array of body part ids to blur. Each must be one of the 24 body part ids.\n *\n * @param backgroundBlurAmount How many pixels in the background blend into each\n * other.  Defaults to 3. Should be an integer between 1 and 20.\n *\n * @param edgeBlurAmount How many pixels to blur on the edge between the person\n * and the background by.  Defaults to 3. Should be an integer between 0 and 20.\n *\n * @param flipHorizontal If the output should be flipped horizontally.  Defaults\n * to false.\n */\nexport function blurBodyPart(\n    canvas: HTMLCanvasElement, image: ImageType,\n    partSegmentation: SemanticPartSegmentation|PartSegmentation[],\n    bodyPartIdsToBlur = [0, 1], backgroundBlurAmount = 3, edgeBlurAmount = 3,\n    flipHorizontal = false) {\n  const blurredImage = drawAndBlurImageOnOffScreenCanvas(\n      image, backgroundBlurAmount, CANVAS_NAMES.blurred);\n  canvas.width = blurredImage.width;\n  canvas.height = blurredImage.height;\n\n  const ctx = canvas.getContext('2d');\n\n  if (Array.isArray(partSegmentation) && partSegmentation.length === 0) {\n    ctx.drawImage(blurredImage, 0, 0);\n    return;\n  }\n  const bodyPartMask =\n      createBodyPartMask(partSegmentation, bodyPartIdsToBlur, edgeBlurAmount);\n\n  ctx.save();\n  if (flipHorizontal) {\n    flipCanvasHorizontal(canvas);\n  }\n  // draw the original image on the final canvas\n  const [height, width] = getInputSize(image);\n  ctx.drawImage(image, 0, 0, width, height);\n\n  // \"destination-in\" - \"The existing canvas content is kept where both the\n  // new shape and existing canvas content overlap. Everything else is made\n  // transparent.\"\n  // crop what's not the person using the mask from the original image\n  drawWithCompositing(ctx, bodyPartMask, 'destination-in');\n  // \"destination-over\" - \"The existing canvas content is kept where both the\n  // new shape and existing canvas content overlap. Everything else is made\n  // transparent.\"\n  // draw the blurred background on top of the original image where it doesn't\n  // overlap.\n  drawWithCompositing(ctx, blurredImage, 'destination-over');\n  ctx.restore();\n}\n","export const PART_CHANNELS: string[] = [\n  'left_face',\n  'right_face',\n  'left_upper_arm_front',\n  'left_upper_arm_back',\n  'right_upper_arm_front',\n  'right_upper_arm_back',\n  'left_lower_arm_front',\n  'left_lower_arm_back',\n  'right_lower_arm_front',\n  'right_lower_arm_back',\n  'left_hand',\n  'right_hand',\n  'torso_front',\n  'torso_back',\n  'left_upper_leg_front',\n  'left_upper_leg_back',\n  'right_upper_leg_front',\n  'right_upper_leg_back',\n  'left_lower_leg_front',\n  'left_lower_leg_back',\n  'right_lower_leg_front',\n  'right_lower_leg_back',\n  'left_feet',\n  'right_feet'\n];\n","/** @license See the LICENSE file. */\n\n// This code is auto-generated, do not modify this file!\nconst version = '2.0.5';\nexport {version};\n"]},"metadata":{},"sourceType":"module"}