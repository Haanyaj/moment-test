{"ast":null,"code":"import { useState, useEffect } from 'react';\nlet stores = {};\nlet subscriptions = {};\n\nconst defaultReducer = (state, payload) => payload;\n/** The public interface of a store */\n\n\nclass StoreInterface {\n  constructor(name, store, useReducer) {\n    this.name = name;\n    useReducer ? this.dispatch = store.setState : this.setState = store.setState;\n\n    this.getState = () => store.state;\n\n    this.subscribe = this.subscribe.bind(this);\n  }\n  /**\n   * Subscribe to store changes\n   * @callback callback - The function to be invoked everytime the store is updated\n   * @return {Function} - Call the function returned by the method to cancel the subscription\n   */\n\n  /**\n  *\n  * @param {callback} state, action\n  */\n\n\n  subscribe(callback) {\n    if (!callback || typeof callback !== 'function') {\n      throw `store.subscribe callback argument must be a function. got '${typeof callback}' instead.`;\n    }\n\n    if (subscriptions[this.name].find(c => c === callback)) {\n      console.warn('This callback is already subscribed to this store. skipping subscription');\n      return;\n    }\n\n    subscriptions[this.name].push(callback);\n    return () => {\n      subscriptions[this.name] = subscriptions[this.name].filter(c => c !== callback);\n    };\n  }\n\n  setState() {\n    console.warn(`[React Hookstore] Store ${this.name} uses a reducer to handle its state updates. use dispatch instead of setState`);\n  }\n\n  dispatch() {\n    console.warn(`[React Hookstore] Store ${this.name} does not use a reducer to handle state updates. use setState instead of dispatch`);\n  }\n\n}\n\nfunction getStoreByIdentifier(identifier) {\n  const name = identifier instanceof StoreInterface ? identifier.name : identifier;\n\n  if (!stores[name]) {\n    throw `Store with name ${name} does not exist`;\n  }\n\n  return stores[name];\n}\n/**\n * Creates a new store\n * @param {String} name - The store namespace.\n * @param {*} state [{}] - The store initial state. It can be of any type.\n * @callback reducer [null]\n * @returns {StoreInterface} The store instance.\n */\n\n/**\n *\n * @param {reducer} prevState, action - The reducer handler. Optional.\n */\n\n\nexport function createStore(name, state = {}, reducer = defaultReducer) {\n  if (typeof name !== 'string') {\n    throw 'Store name must be a string';\n  }\n\n  if (stores[name]) {\n    throw `Store with name ${name} already exists`;\n  }\n\n  const store = {\n    state,\n    reducer,\n\n    setState(action, callback) {\n      this.state = this.reducer(this.state, action);\n      this.setters.forEach(setter => setter(this.state));\n\n      if (subscriptions[name].length) {\n        subscriptions[name].forEach(c => c(this.state, action));\n      }\n\n      if (typeof callback === 'function') callback(this.state);\n    },\n\n    setters: []\n  };\n  store.setState = store.setState.bind(store);\n  subscriptions[name] = [];\n  store.public = new StoreInterface(name, store, reducer !== defaultReducer);\n  stores = Object.assign({}, stores, {\n    [name]: store\n  });\n  return store.public;\n}\n/**\n * Returns a store instance based on its name\n * @callback {String} name - The name of the wanted store\n * @returns {StoreInterface} the store instance\n */\n\nexport function getStoreByName(name) {\n  try {\n    return stores[name].public;\n  } catch (e) {\n    throw `Store with name ${name} does not exist`;\n  }\n}\n/**\n * Returns a [ state, setState ] pair for the selected store. Can only be called within React Components\n * @param {String|StoreInterface} identifier - The identifier for the wanted store\n * @returns {Array} the [state, setState] pair.\n */\n\nexport function useStore(identifier) {\n  const store = getStoreByIdentifier(identifier);\n  const [state, set] = useState(store.state);\n  useEffect(() => {\n    if (!store.setters.includes(set)) {\n      store.setters.push(set);\n    }\n\n    return () => {\n      store.setters = store.setters.filter(setter => setter !== set);\n    };\n  }, []);\n  return [state, store.setState];\n}","map":{"version":3,"sources":["/home/haan/application-web/touch31_app/node_modules/react-hookstore/src/index.js"],"names":["useState","useEffect","stores","subscriptions","defaultReducer","state","payload","StoreInterface","constructor","name","store","useReducer","dispatch","setState","getState","subscribe","bind","callback","find","c","console","warn","push","filter","getStoreByIdentifier","identifier","createStore","reducer","action","setters","forEach","setter","length","public","Object","assign","getStoreByName","e","useStore","set","includes"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react';\n\nlet stores = {};\nlet subscriptions = {};\n\nconst defaultReducer = (state, payload) => payload;\n\n/** The public interface of a store */\nclass StoreInterface {\n  constructor(name, store, useReducer) {\n    this.name = name;\n    useReducer ?\n      this.dispatch = store.setState : this.setState = store.setState;\n    this.getState = () => store.state;\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  /**\n   * Subscribe to store changes\n   * @callback callback - The function to be invoked everytime the store is updated\n   * @return {Function} - Call the function returned by the method to cancel the subscription\n   */\n\n  /**\n  *\n  * @param {callback} state, action\n  */\n  subscribe(callback) {\n    if (!callback || typeof callback !== 'function') {\n      throw `store.subscribe callback argument must be a function. got '${typeof callback}' instead.`;\n    }\n    if (subscriptions[this.name].find(c => c === callback)) {\n      console.warn('This callback is already subscribed to this store. skipping subscription');\n      return;\n    }\n    subscriptions[this.name].push(callback);\n    return () => {\n      subscriptions[this.name] = subscriptions[this.name].filter(c => c !== callback);\n    }\n  }\n\n  setState() {\n    console.warn(`[React Hookstore] Store ${this.name} uses a reducer to handle its state updates. use dispatch instead of setState`)\n  }\n\n  dispatch() {\n    console.warn(`[React Hookstore] Store ${this.name} does not use a reducer to handle state updates. use setState instead of dispatch`)\n  }\n}\n\nfunction getStoreByIdentifier(identifier) {\n  const name = identifier instanceof StoreInterface ? identifier.name : identifier;\n  if (!stores[name]) {\n    throw `Store with name ${name} does not exist`;\n  }\n  return stores[name];\n}\n\n/**\n * Creates a new store\n * @param {String} name - The store namespace.\n * @param {*} state [{}] - The store initial state. It can be of any type.\n * @callback reducer [null]\n * @returns {StoreInterface} The store instance.\n */\n\n /**\n  *\n  * @param {reducer} prevState, action - The reducer handler. Optional.\n  */\nexport function createStore(name, state = {}, reducer=defaultReducer) {\n  if (typeof name !== 'string') {\n    throw 'Store name must be a string';\n  }\n  if (stores[name]) {\n    throw `Store with name ${name} already exists`;\n  }\n\n  const store = {\n    state,\n    reducer,\n    setState(action, callback) {\n      this.state = this.reducer(this.state, action);\n      this.setters.forEach(setter => setter(this.state));\n      if (subscriptions[name].length) {\n        subscriptions[name].forEach(c => c(this.state, action));\n      }\n      if (typeof callback === 'function') callback(this.state)\n    },\n    setters: []\n  };\n  store.setState = store.setState.bind(store);\n  subscriptions[name] = [];\n  store.public = new StoreInterface(name, store, reducer !== defaultReducer);\n\n  stores = Object.assign({}, stores, { [name]: store });\n  return store.public;\n}\n\n/**\n * Returns a store instance based on its name\n * @callback {String} name - The name of the wanted store\n * @returns {StoreInterface} the store instance\n */\n\nexport function getStoreByName(name) {\n  try {\n    return stores[name].public;\n  } catch(e) {\n    throw `Store with name ${name} does not exist`;\n  }\n}\n\n/**\n * Returns a [ state, setState ] pair for the selected store. Can only be called within React Components\n * @param {String|StoreInterface} identifier - The identifier for the wanted store\n * @returns {Array} the [state, setState] pair.\n */\nexport function useStore(identifier) {\n  const store = getStoreByIdentifier(identifier);\n\n  const [ state, set ] = useState(store.state);\n\n  useEffect(() => {\n    if (!store.setters.includes(set)) {\n      store.setters.push(set);\n    }\n\n    return () => {\n      store.setters = store.setters.filter(setter => setter !== set)\n    }\n  }, [])\n\n  return [ state, store.setState ];\n}\n"]},"metadata":{},"sourceType":"module"}